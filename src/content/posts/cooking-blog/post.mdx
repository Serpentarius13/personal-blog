---
slug: "astro-blog-from-scratch"
title: "Cooking static blog with Astro"
description: "There's many ways to build a static site. I've gone with Astro and want to share what DX I had and what paths I took."
date: 2024-06-10
image: "./Preview.jpg"
imageAlt: "A Vitruvian man with head as Astro logo and Penis as Vanilla JS script holding Tailwind, Daisy, Solid and Shiki, with legs as Lighthouse & Robots.txt logo"
tags: ["astro", "shiki", "markdown", "seo", "tailwind", "lighthouse", "mdx"]
draft: false
---
import MdxImage from "@/components/mdx/MdxImage.astro";


import { Counter } from "./Counter.tsx";

import HighlightCat from "./HighlightCat.astro";


## Introduction to the kitchen

It's been a long time since I build any personal project and I've decided to build a personal site ~~so the internet would notice me~~
to share some of my findings to help myself and others learn interesting stuff. As [Richard Feynmann](https://en.wikipedia.org/wiki/Richard_Feynman) said:

> If you cannot explain something in simple terms, you don't understand it

*P.S. Please don't look at it as a much of educative article, more like personal opinion/experience.
If you want to learn Astro, open the docs and follow the tutorial!*

I've heard about Astro a lot before and even used it in one of my work projects,
but I have never dived deep enough to figure out why people even need static sites and why not just build everything in React.

There are frameworks which provide Static Site Generation (SSG) and Server Side Rendering (SSR) like `Next.js`, `Nuxt`, `Remix`, `SvelteKit`
and the good-ol `Gatsby`, but I feel Astro is a frontier in pushing SSG
to more like a web standard. Apart from the fact that it provides
very comforting Developer Experience with native `Markdown` and `MDX` parsing and many integrations with `CMS` tools,
it also builds upon the new approach to web-development: `Islands Architecture`

### A history lesson

From the ancient times of PHP and very early releases of Netscape, people were thinking about interactivity. It made websites alive!
And JavaScript provided that, even while being a tricky language. But as everybody probably think and know now as it is a hot topic,
JavaScript could actually slow down the website. It is especially aparent on mobile devices as parsing and executing even gzipped
code is consuming battery charge and taking the small network speed they have. And as many would cite, if the page is slow,
your business will feel that in suffering of losing its audience as it feels that website is cheap and maybe even a scam.

Plus to that, when using just Client-Side rendering like Vue or React provides you with, 
your website may not be as SEO-friendly and crawlable by Googlebot (although it betters over time). On the other hand,
when loading a webpage, your users may see a sudden flash, maybe even prolonged one while any scripts load at all,
which could ruin every experience.

Here I want you to understand a difference between two terms: `Website` and `Web app`. 

Client-side frameworks have received their growth because it became trendy and actually very efficient to build
`Web apps` that are no less than real computer apps that you download an installer for, while being much more easy to work with.
Even so, there are apps that ship to desktop while running Frontend WebView under the hood, like Electron and Tauri.
They are in the demand, and VSCode, Discord, Spotify, even FeedTheBeast Minecraft launcher are running Electron,
because it is easy to build after having experience with using these tools on frontend. Those have a very high degree
of interactivity.

This is a Web App ([By freepik](https://www.freepik.com/free-vector/dashboard-user-panel-template_6144806.htm#fromView=search&page=1&position=1&uuid=d5fb43c7-d255-44ab-b398-10ed05df0c04)):

import webapp from './Webapp.jpg';

<MdxImage src={webapp}  alt="Web app" />  

And on the other side of the coin is `Websites`. Those are news magazines, personal portfolio pages, blog sites,
even e-commerce, documentation pages and so on. There are no complex logic behind them. They may include few widgets
like a small calendar or rss feed button, but ultimately they may use Wordpress or some other CMS, or even build 
with native JavaScript, as most of the content is really just HTML & CSS. Those may have at best a custom mobile burger
and some carousel with one Call to Action modal or a form.

import website from './Website.jpg';

This is a Website ([By freepik](https://www.freepik.com/free-vector/liquid-effect-landing-page_4335546.htm#fromView=search&page=1&position=4&uuid=df62a421-566a-4411-a2a3-96f7f2f74b78)):
<MdxImage src={website}  alt="Website" />  

`Websites` may not even require build step. There is not much dynamic info on them, so they could be easily cached.
`Web apps` may update data each millisecond you would keep track of your ad revenue. They may show you tens of dozens
complex charts that you could look at, while running in your browser.

### Why Astro?

And so, to use React, Vue and other ecosystems and approaches, people have introduced `Meta frameworks` like
`Next.js` for React and `Nuxt` for Vue. Those meta frameworks are responsible for making experience with the technology
applicable to build a landing page for your web app with providing developer to `Server-Side render` their app, and then
`hydrate` every interactive part to the client. That means, instead of sending empty `HTML` pages
with modules to bootstrap the application at user's device expense, there would be a 
`server-entry.js` file generated with `express` or `Nitro` under the hood to serve requests from `Node` or other runtime.

It makes app faster to serve: your database and file system is much closer to the server, which reduces latency
rather than fetching it from outside. Plus, server-side environment provides an ability to have secrets in it without
them being easily leaked like it happens on the client. So, the app becomes more coupled and `universal`.

Having mastered Vue, you could use that to build a e-commerce store, even when Vue is a framework
for reactivity and interactivity, not concerned with what SEO is.

With Meta frameworks, all problems related with Time-To-Interactive metric, Seo, and flashes would seemingly be gone.
But even though SSR can be cached and managed properly, having to adapt this mental model could be quite complex.
Trying to dissect where components run and should run is a mental excersise. You can feel it most crucially
in "the new Next.js" with `React Server Components` adaptation.

> Where do I put my code, on the server, or on the client?

> Where do I use "use client"

> Where do I get the data from db?

> Is it safe here?

And it is easy to make mistakes, just how it may be easy to ruin your memory handling in C or run into undefined behaviour,
while mistake could go unnoticed until it ruins someone else's (or even yours) experience.

Astro is different. There is a clear separation between what runs where. It is achieved through
that paradigm:

> Everything is either prerendered or ran on the server, and you may add JavaScript precisely where you want it.

An example of this would be this tree of components:

```astro title=index.astro
<ComponentA>

  <ComponentB>
    <ComponentC>
      <ComponentD client:load> <!-- Here, ComponentD is hydrated to the client,
      but everything else is not. -->
      </ComponentD>
    </ComponentC> <!-- If component C is a React component
    and has complex logic, it would not be working,
    and nothing would be sent to the client  -->
  </ComponentB>

</ComponentA>
```

So, unless you specify explicitly to send component to the client, it would not be interactive. In SSR, that is reversed,
which may not be a good way to handle building `Websites`. And here's where Astro shines.

**Grab that!**

<Counter client:visible />

Sorry for that bunch of Preact bundle I got into your browser right now üëÄ However, you didn't actually download
it before you have seen it, because I added it like so, with a directive: `<Counter client:visible />`. It works
with `IntersectionObserver` that tracks the element's visibility on the screen, and if it is visible, it will
`hydrate it to the client`.

That makes Astro a meta-framework for every UI-library there is: `Solid`, `Svelte`, `Preact` are no exceptions.
It is simple and efficient, easily landing you all 100's on Lighthouse score.

Astro prevents mistakes of leaking JavaScript, helps with in-built optimizations,
provides an ecosystem of plugins and integrations for every
task you'd have at building and very thorough thourough documentation and warming community at Discord that helps.

So, here's my path!

## Mistook apples for oranges

I thought the fastest way to learn and actually use was to copy someone else's template and build upon it.
[Astro Erudite](https://github.com/jktrn/astro-erudite) as I was searching through github as it had
everything that I wanted and more. So, I frivoulously cloned it and right away decided to switch UI kit to `Daisy` as
I see `shadcn-ui` as a more SaaS-y approach to styling. That was my horrible mistake and a great blessing,
since I spent an immeasurable amount of time trying to decode someone else's code and decisions while swapping components
one by one. At last, I ended with a half of enscribe's child and my own homunculus:

![Here's the result](./homunculus.png)

I wanted to learn more about Astro after finishing rebuilding this template, but at the end I just snapped
and started my own project. I took a lot of inspiration and learning in parts which I didn't understood well from it, so thank you
[the great Open-Sourcer](https://github.com/jktrn/astro-erudite)! 

So, here's my take on Astro. You can get all the source snippets from [the repo](https://github.com/Serpentarius13/personal-blog).
Note that sometimes I'm citing partial snippets to show the main ideas, but the full code is always available there. Also,
I use `Astro v4.15.11`, so check your version to avoid inconcistencies and misinformation about newest practices.

## Tasty menu

To build a static website, you will come at some issues right away and some will come later.
Here's my full list (aside from the Astro itself, that the documentation help you will for):

- How to style it? üñåÔ∏è
- Where to get icons? üéé
- How to make MDX work? üñäÔ∏è
- How to highlight code? üåà
- How to add client-side logic? üè≠
- How to make it searchable? üîç
- How to store persistent data? üíæ
- How to deploy it? üöÄ
- How to make it cool? üòé

That would be the contents of this article. Let's begin!

## Instagrammy bacon and eggs

As a styling solution I decided to stick with [`Tailwind`](https://tailwindcss.com/) as it is the fastest way to write `CSS`.

To get started, I had to enter just one command:

```bash
pnpm astro add tailwind
```
Here, Astro CLI installed integration for me and created `tailwind.config.ts` for me. You could use other name,
for example `solid` to install solid integration. Or you may have added `@astrojs/tailwindcss` package yourself
and put it into integrations:

```ts title=astro.config.ts
import tailwind from "@astrojs/tailwind";

// in config
integrations: [ tailwind() ],
```

For the UI-library, as I mentioned, I took [`daisyUI`](https://daisyui.com/) which got me tinker with it for a bit before
actually getting the way to use it, but in the end it was much worth it as I didn't have to write many usable
things from scratch and got an immensely good home-looking design for free, which would take ages to build from scratch.

import ThemeDropdown from "@/components/astro/ThemeDropdown.astro";

### Multiple dressings for choice

One of the most enjoyable things about Daisy is its inbuilt themes support. Take a look at the theme picker right here:

<ThemeDropdown class="!dropdown-top not-prose"> Click me!</ThemeDropdown>

And Daisy has even more themes, although I would hesitate to add them all because the bundle size would grow a little.

This dropdown is built with the use of cool interaction based on `MutationObserver`, which powers I lent for the first time.
While my component renders a dropdown that changes a document `data-theme` property:

```astro title=Layout.astro
---

<div
  class="dropdown"
>
  <div
    tabindex="0"
    role="button"
  >
    Button
  </div>
  <ul>
    {
        // render all themes from config
      THEMES.map((theme) => {
        return (
            // add data-theme to showcase new colors in a button
          <li data-theme={theme}>
            <div
            // give ids to add event listeners later
              id={`theme-switcher-${theme}`}
            >
              {theme}
            </div>
          </li>
        );
      })
    }
  </ul>
</div>

<script>
  const handleSwitchTheme = (theme: string) => {
    document.documentElement.dataset.theme = theme;
  };

  // add event listeners to switch document theme
  document.querySelectorAll(`[id^="theme-switcher-"]`).forEach((el) => {
    el.addEventListener("click", (event) => {
      event.preventDefault();
      const theme = (event.target as HTMLElement)?.parentElement?.dataset
        .theme as string;
      handleSwitchTheme(theme);
    });
  });
</script>
```

Script loaded in the document watches the changes and reacts with localStorage syncing, while loading the theme from it at first too:
  
```ts
<script is:inline>
    const darkThemes = ["dark", "aqua"];
    const THEME_KEY = "theme";
    const getThemePreference = () => {
    // if saved return that
    if (typeof localStorage !== "undefined") {
        const theme = localStorage.getItem(THEME_KEY);

        if (theme) {
          return theme;
        }
    }

        // grab user's preferred color scheme if not
    return window.matchMedia("(prefers-color-scheme: dark)").matches
        ? // must be synced on its own without config because I don't wanna import themes into head on page load
        "night"
        : "autumn";
    };

    const getDocumentTheme = () => {
      return document.documentElement.dataset.theme;
    };

    const setDarkMode = (document) => {
      const theme = getThemePreference();

      document.documentElement.dataset.theme = theme;
    };

    setDarkMode(document);

    if (typeof localStorage !== "undefined") {
      // creating observer instance.
      // when `data-theme` defined below changes, it syncs local storage
      const observer = new MutationObserver(() => {
          const theme = getDocumentTheme();
          if (!theme) return;
          localStorage.setItem(THEME_KEY, theme);
      });

      observer.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
      });
    }
</script>
```

This is way too cool! üòé

One important thing about this approach is that I had to make script `inline` and put it in the `<head>`,
so the website would not ~~FART~~ flicker when loading initially as it would load the script ahead before rendering the page.
`Inline` means that Astro would not optimize my script and bundle it as a `module`, but leave it as-is. 
It removes the ability to use TypeScript and import utilities from other parts of the project, but the importance here
is to provide small as possible way to load the theme without any flickers.

### Writing attractive invitations

As for typography, Daisy recommends using `@tailwind/typography` package, which I went with. It is nice on itself,
and very tweakable - for example when rendering markdown I wanted to remove this plugin's styles on `<code>` blocks,
and here its done with just one line:

```html
<div class="prose prose-code:not-prose">
```

Another thing I want to mention is `cn` function:

```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

I think you can add it literally in any project with Tailwind,
since it is a live-saver as it does two things:

- It merges all classes with the way resembling `CSS specifity` - last one apply.
- And it removes unnecessary classes when duplicates appear. For example, with `mr-2` and `ml-2` appearing, it would collapse them to just `mx-2`.
- It provides nice API to work with conditional classes instead of ugly `&&`'s:

```ts
<div className={cn("class-1 class-2", {
    "class-3 class-4": isSomeCondition,
})}>
```

Well, anyway, some may find it worse than `&&`'s, but to each their own üêà

### Looking for stickers 

Every website probably needs icons, and almost every time I start a new project I look for a way to get them.
Some people make a map like that:

```ts title=icons.tsx
export const ICONS = {
  General: {
    Github,
    Twitter,
    Telegram,
    RSS,
  } // and so on
}
```

Some people use [`feathers`](https://feathericons.com/) and add icons directly to their css.

Some people use [`Lucide`](https://lucide.dev/) or [`Iconify`](https://iconify.design/) with inbuilt components for frameworks.
I have gone with it too, since Astro has an `astro-icon` integration.
However, it required me to specify what icons I wanted to have, otherwise it warned me
that it would load them all in the bundle. I did so, and was quite unhappy:

```ts title=config.ts
export enum IconSet {
  Catpuccin = "catpuccin",
  // other sets
}

export const ICONS = {
  [IconSet.Catpuccin]: {
    typescript: "typescript",
    // other icons
  },
} as const;
```

And in Astro config:

```ts title=astro.config.ts
import { ICONS } from "config";

import icon from 'astro-icon'

export const config = {
  integrations: [ icon({ icons: Object.values(ICONS) }) ], // map all used icons somehow
};
```

```astro 
<AppIcon set={IconSet.Catpuccin} name="typescript" /> <!-- type inferred -->
```

With that, I couldn't even use this component in my UI-libraries code too. So, it became a mess.

Then, I stumbled upon [`@iconify/tailwind package`](https://iconify.design/docs/usage/css/tailwind/#iconify-for-tailwind-css)
which makes `tailwind` work with iconify through classes. Here's how it looks:

```ts tailwind.config.ts blurredLines={2-3,7-8}
  plugins: [
    daisyui,
    typography,
    addIconSelectors({
      prefixes: ["line-md", "logos", "la", "game-icons"],
    }),
    scrollbar,
  ],
```

And in the code:

```html
<span class="iconify la--address-book"></span>
```

To render: <span class="iconify la--address-book"></span>

I made a small wrapper component in Preact (as I decided it would be my rendering tool)
for it, so I could tweak it later and find all my icons and also automatically add `iconify` class, it is needed
to not add all needed icon styles to every icon class and reuse just one:

```tsx title=Icon.tsx 
import { cn } from "@/lib/cn";
import type { FC, HTMLAttributes } from "preact/compat";

interface Props extends HTMLAttributes<HTMLSpanElement> {
  className?: string;
}

export const Icon: FC<Props> = ({ className, ...rest }) => {
  return <span {...rest} className={cn("iconify", className)} />;
};
```

If i'd wanted, I would just use a class in my other UI component if I could not import this one there. Problem solved.

## Restaurant's layout

There are ways to show Markdown on the page: you could use `.md` file extension in `pages/` folder like so:

```
project
‚îî‚îÄ‚îÄ‚îÄpages
‚îÇ   ‚îÇ   index.astro
‚îÇ   ‚îÇ   some-page.md
```

Or as a bunch of files later fetchable with `import.meta.glob`:

```ts
const blogPosts = import.meta.glob("./blog/*.md"); // gets all files in blog directory ending with *.md

for (const post of blogPosts) {
  console.log(post);
}
```

But recommended approach is to use [`Content Collections`](https://docs.astro.build/en/guides/content-collections/).
It is an idiom of framework with reserved `content/` folder at `src`
directory of the project. Here's my `content/` while writing this article:

![My content folder](./Content.png)

There is one important file: `config.ts` that looks like so:

```ts title=config.ts
import { defineCollection, z } from "astro:content";

const postsCollection = defineCollection({
  type: "content",
  schema: ({ image }) =>
    z
      .object({
        title: z
          .string()
          .max(60, "Title should be 60 characters or less for optimal Open Graph display."),
        description: z
          .string()
          .max(155, "Description should be 155 characters or less for optimal Open Graph display."),
        date: z.coerce.date(),
        image: image(), // here is an `image` zod object by Astro
        // we could check whether image has required dimensions for example like so:
        // image().refine(image => image.width === 1200 && image.height === 630, {
        //   message: 'The image must be exactly 1200px √ó 630px for Open Graph requirements.',
        // })
        imageAlt: z.string(),
        tags: z.array(z.string()).optional(),
        draft: z.boolean().optional(),

        trackIndex: z.number().optional(),
        trackName: z.string().optional(),
      })
      .superRefine((data, ctx) => {
        if ((data.trackIndex && !data.trackName) || (!data.trackIndex && data.trackName)) {
          return ctx.addIssue({
            path: ["trackIndex", "trackName"],
            code: z.ZodIssueCode.custom,
            message: "trackIndex and trackName must be used together",
          });
        }
      }),
});

export const collections = {
  posts: postsCollection,
};
```

`config.ts` uses `defineCollection` helper alongsize re-exported zod's `z` to build type-safe schemas for blog posts. Then, it is important
to re-export `collections` constant for astro to notice it. When you start your project with `astro dev` or run `astro sync` directly,
it would generate types for your collection to use in the project:

```ts
import { getCollection } from 'astro:content'

const posts = await getCollection('posts') // of type CollectionEntry<'posts'>
```

And here's my `frontmatter` - a metadata of the post:

```mdx
---
slug: "astro-blog-from-scratch"
title: "Cooking static blog with Astro"
description: "There's many ways to build a static site. I've gone with Astro and want to share what DX I had and what paths I took."
date: 2024-06-10
image: "./Preview.jpg"
imageAlt: "A Vitruvian man with head as Astro logo and Penis as Vanilla JS script holding Tailwind, Daisy, Solid and Shiki, with legs as Lighthouse & Robots.txt logo"
tags: ["astro", "shiki", "markdown", "seo", "tailwind", "lighthouse", "mdx"]
draft: true
---
```

I used a `slug` property myself, but Astro generates it automatically from file name. I wanted more consistency
and control here, since later I would like to save some data in db for each post.

Then, we could render posts as a list of links:

```astro title=src/pages/index
---
import { getCollection } from 'astro:content'

const posts = await getCollection('posts')
---

<ul>
  Links to articles:
  {
    posts.map(post => <li><a href={`/blog/${post.slug}`}>{post.data.title}</a></li>)
  }
</ul>
```

And use `dynamic routes` to render each one:

```astro title=src/pages/blog/[...slug].astro
---
import type { GetStaticPaths, InferGetStaticPropsType } from "astro";
import { getCollection } from "astro:content";

export const getStaticPaths = (async () => {
  const posts = await getCollection('posts')

  // we statically generate an array of each param:props key-value pairs
  // that Astro will use to generate [slug].html files later
  return posts.map((post, ix) => {
    return {
      params: { slug: post.slug },
      props: { post },
    };
  });
}) satisfies GetStaticPaths;

interface Props extends InferGetStaticPropsType<typeof getStaticPaths> {}

const { post } = Astro.props; // type-inferred { post: CollectionEntry<"posts"> }
const { Content, headings, remarkPluginFrontmatter } = await post.render();
---

<Content />
```

From `render` method we receive `<Content>` component that we could directly use in Astro markup,
list of all headings flattened out and `remarkPluginFrontmatter` that carries data we passes to it (for example,
from readingTime plugin). 

As this is all generated upfront, we could include complex logic to fetch data from `CMS`, run CPU-intensive tasks
like sorting or optimizing, and this would not hurt our users experience.

### Combining the kitchen's efforts

Astro uses [`Unified`](https://unifiedjs.com/) for parsing markdown under the hood.
Unified is a toolset for processing Markdown, MDX, human-text and other types of content into `AST`'s (Abstract Syntax Trees)
and vice-versa - transforming them back and forth between each other to give you the result you need. It gives developers 
a lot of flexibility to customize how the content goes from being an `.mdx` file to HTML being presented to the user.

There are two ~~remarkable~~ libraries in this ecosystem I needed: `remark` and `rehype`. `Remark` is a markdown processor,
while `rehype` is an `AST`-to-`HTML` processor. For example, here's the `remark` plugin `recipe` from `Astro` docs, that adds
reading time to article's metadata:

```ts
import type { Root } from "mdast";
import { toString } from "mdast-util-to-string";
import getReadingTime from "reading-time";

export function remarkReadingTime() {
  return function (tree: Root, { data }: any) {
    const textOnPage = toString(tree);
    const readingTime = getReadingTime(textOnPage);
    // readingTime.text will give us minutes read as a friendly string,
    // i.e. "3 min read"
    data.astro.frontmatter.readingTime = readingTime.text;
  };
}
```

It converts a tree to text for a moment and then calculates the reading time from it.

As for `rehype`, I haven't wrote a plugin myself as I didn't need too: [the ecosystem provides them at large](https://unifiedjs.com/explore/).
I used those four guys:
- `rehype-slug` for making heading's slugs to later target them in links via #heading
- `rehype-autolink-headings` to add links to headings, so users would be able to click on them and share with others
- `rehype-sectionize` to add `section` tags wrapping each heading to make it easier to target and style and for better SEO
- `rehype-external-links` to add `rel="nofollow"` and `target="_blank"` to external links and style them accordingly

Also, there's `rehype-pretty-code` for handling and styling code blocks which I tried to use, but it doesn't support multiple themes with `MDX` yet because
of some unknown bug, so I had to put it down for something else: about this in the next section.

To parse MDX itself there's an integration `@astrojs/mdx` that works with
all remark and rehype plugins. When used, it receives all options passed to
`markdown` property in the config, so there's no need to copy them:

```ts title=astro.config.ts
 markdown: {
    syntaxHighlight: false,
    remarkPlugins: [remarkReadingTime],
    rehypePlugins: [
      [rehypeSlug, rehypeSlugOptions],
      rehypeSectionize,
      [rehypeExternalLinks, { target: "_blank" }],
      [rehypeAutolink, { behavior: "wrap" }],
    ],
  },

  integrations: [
    mdx(), // all plugins copied here automatically
  ],
```

## Exquisite solyanka

```rust title="main.rs"
const explanation: &'static str = r#"
    Solyanka (also spelled sel'yanka) is an old Russian national soup dish.
    The word "solyanka" has a figurative meaning in Russian as
    'mishmash', 'hodgepodge', 'disorder',
    'diverse mixture of the most diverse, hetergenous elements'
"#
```

As a programmer's education resource, I was of course obliged (unlike certain `linkedin` fella) to make working with code blocks
as smooth as possible. That meant syntax highlighting, line numbers, diffing, copy button and so on.

For highlighting code there exist two libraries that I know of: `Prism` and `Shiki`. First of all, Shiki is a cool name,
second of all, Prism seemed quite outdated and abandoned, and third of all, [this Anthony Fu's article](https://nuxt.com/blog/shiki-v1) convinced me that it was great.
Shiki, contrary to Prism, works not only at the client, but ahead of the time compiling at the server too,
and it is actually used in `VSCode` as a highlighter, so great support and high amount of themes to choose is imminent.

You could write a plugin yourself, but it would be a lot of work of course.
`rehype-pretty-code` plugin I mentioned above is a great one as it provides
almost all the features I needed out of the box, but the problem I mentioned was a big turn-off for me as I wanted to do multiple (2 YEAH!)
themes instead. At the time I was trying to make it work and stumbled upon [`expressive-code`](https://expressive-code.com/).

`expressive-code` is a library that is used under the hood in  [`Astro Starlight` documentation template](https://starlight.astro.build/).
Out of the box it was way cooler than `rehype-pretty-code` and there was no issues at all. I even wrote my own plugin to blur some lines like that:

```ts blurredLines={1-2}
import {
  secret,
  anotherSecret
} from "@expressive-code/core";1

secret(anotherSecret)
```

since it didn't have its own. Here:

```ts title=plugins/expressive-code-blur.ts
import { type ExpressiveCodePlugin } from "@expressive-code/core";
import { addClassName } from "@expressive-code/core/hast";

export interface PluginBlurSettings {
  blurredLines: Record<number, boolean> | undefined;
}

declare module "@expressive-code/core" {
  export interface ExpressiveCodeBlockProps extends PluginBlurSettings {}
}

export function pluginBlurLines(): ExpressiveCodePlugin {
  return {
    name: "Blur lines",
    baseStyles: `
      .blurred:before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.1);
        z-index: 1;
        backdrop-filter: blur(4px);
      }
      
      .blurred {
        position: relative;
      }     
    `,
    hooks: {
      preprocessMetadata: ({ codeBlock: { metaOptions, props } }) => {
        // Transfer meta options (if any) to props
        const range = metaOptions.getRange("blurredLines");

        if (range) {
          // Init hashmap to store all blurred line numbers
          const blurredLines: Record<number, boolean> = {};
          // Match all pairs with regex
          const matches = range.matchAll(/(\d+-\d+)|(\d+(?!-))/g);
          for (const m of matches) {
            const value = m[0];

            // Check if it is a range
            if (value.indexOf("-") > -1) {
              const [start, end] = value.split("-").map(Number);
              if (end <= start) throw new Error("Invalid range");
              for (let i = start; i <= end; i++) {
                blurredLines[i] = true;
              }
              continue;
            }
            // Else it is a single number
            blurredLines[Number(value)] = true;
          }

          const map: Record<number, boolean> = {};

          props.blurredLines = blurredLines;
        }
      },
      postprocessRenderedLine: ({ codeBlock, renderData, lineIndex, line }) => {
        if (codeBlock.props.blurredLines) {
          // use lineIndex to check if it should be blurred
          if (lineIndex + 1 in codeBlock.props.blurredLines) {
            // add blurred class to the line
            addClassName(renderData.lineAst, "blurred");
          }
        }
      },
    },
  };
}
```

And in config:

```ts title=astro.config.ts
import expressiveCode from "astro-expressive-code";
import { pluginBlurLines } from "./plugins/expressive-code-blur";

// in config
 expressiveCode({
      plugins: [... pluginBlurLines() ...],
 }),
```

[Full API example is referenced here](https://expressive-code.com/reference/plugin-api/)

`expressive-code` gave me highlights, line numbers, diffing, copy button and pretty wrappers for blocks instantly for free,
which I liked and went along with it. The library may miss some extended features,
but it is amendable with plugin API and explanations the docs provide.

One more thing about code blocks: They have `Jetbrains Mono` font, which I think makes code a bit more readable,
provided by `fontsource` like so:

```astro title=/src/blog/[...slug].astro
---
import "@fontsource-variable/jetbrains-mono";
---
```

## DIY noodles

import HighlightToc from "./HighlightToc.astro";

For making app interactive, I went with writing some `addEventListener`'s in vanilla JavaScript, because I wanted 
to freshen my knowledge and make things as primitive as they could be. If I'd wished to go fast, I would use
a UI library that I knew (maybe if it was not `Vue`, as it brings a lot of bundle size), for example, `Svelte` adds just about 2-3kb.

One the most complex interactions was <HighlightToc/>.

It took me some time to research on the needed plugins to make headings and links to render
and also to tweak everything in a `<script>` tag. Some of that was from unnecessary complexity I made up
as I tried to make several different implementations (as in highlight just one
or several headings, what styles to add and so on), and in the end I went the simplest route:

- Highlight every `section` (provided wrapper by `rehype-sectionize`) even remotely on the screen with `IntersectionObserver`
while account for headings margin like so:

```js
const header = document.querySelector("header");
const headerHeight = header ? header.offsetHeight : 0;

const observer = new IntersectionObserver(
  (sections) => {
    sections.forEach((section) => {
      const heading = section.target.querySelector("h2, h3, h4, h5, h6");
      if (!heading) return;

      const id = heading.getAttribute("id");
      const link = document.querySelector(`#toc li a[href="#${id}"]`);

      if (!link) return;

      link.classList[section.isIntersecting ? "add" : "remove"]("seeing");
    });
  },
  {
    rootMargin: `-${headerHeight}px 0px 0px 0px`,
  })

const sections = document.querySelectorAll(".prose section");
sections.forEach((section) => {
  observer.observe(section);
});
);
```

- Add intercepting smooth scroll to the links:

```js
const links = document.querySelectorAll(
    "#toc a[href^='#']",
) as NodeListOf<HTMLAnchorElement>;

for (const link of links) {
      link.addEventListener("click", (event) => {
      event.preventDefault();
      const target = document.querySelector(link.href);
      target?.scrollIntoView({ behavior: "smooth", block: "start" });
    });
}
```

- On mobile, do not add anything and render the block above the article. Maybe in the future I will add a button
in the header to show it full-screen, but now it is just there.

As you can see now, this third block didn't get into production, and there's a button at the top of the screen.
When writing this article, I've been looking at other people's blogs, and noticed that my design was very bloated,
and I wanted to make it simpler. I made a button to close TOC so that it wouldn't bother user's screen when it is not needed.

From that I figured that if you don't know something, you will have a ton of ideas (or none, actually) how to build it,
and may go into a deep rabbit hole of multiple decisions that do not work together, so, here's my two cents:

- See other people work and learn from it
- Plan, always!
- Dont break the plan just because you had a new idea üôÑ Think it thoroughly first

## Detective's favourite tea

For users to discover my content, I have planned to make two features: 

- A paginated blog to "encounter" content (which you could find at [here](/blog))
- A global search bar to "precisely look for" content <HighlightSearch> (which is here) </HighlightSearch>

It would be openable from anywhere and would give user ability to search for any content or keyword.

A global search might be done in backend, but when you have few articles that do not have much content,
I don't think the investment in `Algolia` is worth it. 

While Astro provides [API for pagination out of the box](https://docs.astro.build/en/guides/routing/#pagination), the search is handled by separate libraries.
Coming from Astro docs, I found myself before two choices: [`pagefind`](https://pagefind.app/) and [`fuse.js`](https://www.fusejs.io/).

`pagefind` is a `Rust`-based static search artifacts generator. It makes resources to search at build-time
and an API to call this search from the client. While blazingly-fast sounds cool, at first, I find it difficult
because of the cumbersome way to load `WASM` bundle, artifacts and client-side API that is working through `window` binding.
First, you need to generate it all, then put it in a public folder so you can import js client and so on..

`Fuse.js` is a `JavaScript`-based fuzzy-search library. It has nice API and does its job, but search is very simple.

So, I have decided on Fuse because of its simplicity. Here's how it went:

- Firstly, I wanted to see what happens when I use it over 100 fat articles on the client. It was horrible as initial
HTML Astro sent was about `26 megabytes!`. So, I had another idea.
- I have read recently from Astro docs, that they have added something like "Server actions" with `rpc`-like client.
It was very pleasant to work with as you can import actions all around the project and even in UI libs and scripts,
while having good API that was much better than `fetch` to work with, because actions provided in-built `zod` validation
with type inference and public API.
- So, I have set up something like that:

```ts
export const prerender = false;

export interface SearchRecordResult
  extends Pick<
    SearchRecord,
    "title" | "image" | "description" | "tags" | "slug"
  > {}

// get all records
const collection = await getCollection("posts");

// transform them to searchable records
const records = collection.map((c) => {
  return {
    title: c.data.title,
    content: c.body,
    description: c.data.description,
    tags: c.data.tags || [],
    slug: c.slug,
    image: c.data.image.src,
  };
}) satisfies SearchRecord[];

// initialize Fuse
const fuse = new Fuse(records, {
  keys: ["title", "content", "description", "tags"],
  threshold: 0.45,
  ignoreLocation: true,
  isCaseSensitive: false,
});

export const server = {
  // define action
  searchArticles: defineAction({
    input: z.object({
      // with one search field
      search: z
        .string()
        .max(200, "Search term must be less than 200 characters"),
    }),
    // handle search if no field was provided or when it was
    handler: async ({ search }): Promise<SearchRecordResult[]> => {
      if (!search) return records.map(({ content, ...record }) => record);

      return fuse
        .search(search, { limit: 30 })
        .map(({ item: { content, ...item } }) => item);
    },
  }),
}
```

- And I was rendering it on the client with then-used `Solid.js` and `lazy()` method to load search bar when modal opens.

But, while I was writing this article, I reconsidered the idea of pagefind being insurmountable.
It has a feature that provides exact text excerpts, while with Fuse I was limited to just showing simple cards,
and also filtering, sorting and so on. I wanted to find out if it was possible to build with it the way it would work. And it did.

Thanks to [this library](https://github.com/shishkin/astro-pagefind), it was possible to integrate pagefind with Astro in few clicks.
It provides a `Vite` plugin to incorporate already built pagefind index into dev runtime. And images don't work in dev, but its amendable.
However, I still had to rewrite all my logic for it to work. So, I decided on a plan:

- I would remove actions alltogether, because they load client-side JavaScript that was certainly unnecessary just to make an HTTP-request.
- I would use `pagefind` solely with Astro. That meant I would have to place daisy's `<dialog>` component in the `<body>`.

I made two components: `<SearchTrigger>` and `<SearchDialog>`. The first one is a button that opens the search modal,
which I put in the navbar, while the second one is a modal that is opened with `dialog` element.

I had some tinkering, mostly struggling with building & assets loading. For the lib to work, you need to build your project first,
and then it would load pagefind script with Vite. Assets loading really crushed me though. At first, I placed `dialog` in the body,
but in the wrong place: right below my navbar. It was a critical mistake, as it slowed initial load time immensely, so I moved it lower,
below `<Footer>`:

```astro
<body class="flex flex-col px-3 md:px-1">
  <Navbar>
    <slot name="navbar" slot="default" />
  </Navbar>

  <main class={cn("h-0 flex-1", mainClassname)}>
    <slot />
  </main>
  <Footer />

  <SearchDialog /> <!-- Here -->
</body>
```

I also added `data-pagefind-body` to my blog post container, so only blog post pages would be indexed:
```astro
<div data-pagefind-body>
  <h1 class="mx-auto mb-4 mt-4 w-fit text-6xl font-extrabold">
    {post.data.title}
  </h1>
  <!-- ... -->
```

And with that I had to hide code blocks from being indexed. And `expressive-code`'s plugin API came to rescue again:

```ts
import { type ExpressiveCodePlugin } from "@expressive-code/core";
import { setProperty } from "@expressive-code/core/hast";

export interface PluginIgnoreIndex {}

declare module "@expressive-code/core" {
  export interface ExpressiveCodeBlockProps extends PluginIgnoreIndex {}
}

export function pluginIgnoreIndex(): ExpressiveCodePlugin {
  return {
    name: "Ignore index",

    hooks: {
      postprocessRenderedBlock: ({ renderData }) => {
        // I hid all code blocks, because article's text is sufficient to note about technology
        // plus to that, code blocks are not much readable in search results
        setProperty(renderData.blockAst, "data-pagefind-ignore", "all");
      },
    },
  };
}
```

Also, as a novice bundle optimizer, I was worried that my dev client bundle grew to 1.7mb, however in production it still stays about 200kb,
but the library loads `@pagefind/default-ui`'s css always, which added some kilobytes to CSS bundle. 
I had ripped my hair out since my perfectionism and child-playing got the best of me, and even wrote a `Vite` plugin to remove
css and js from `@pagefind/default-ui` package when the app started and loaded it later with `import()` statements! But that made 
everything worse and was sure as hell not worth it üöë to save few kb.

import HighlightSearch from "./HighlightSearch.astro";

<HighlightSearch> Here's the result! </HighlightSearch> It was quite easy to adapt the lib to work with all daisy themes
and make it adaptive. So, cheers to pagefind and [`Sergey Shishkin`](https://github.com/shishkin)!

## A go to the cellar
   

When I was looking for inspiration, I stumbled again upon [Josh Comeau's website](https://www.joshwcomeau.com/). It had this heart button
with sound effects and my urge to steal was like never before. You may have seen the result of this, angry, or maybe happy now.
<HighlightCat /> to see him! My personal orange üêà

This guy is needed for the purpose of bullying out like clicks from people, there is no mistake. But how to store anything
over one client session in a static website? Its honestly so cool that these days you can setup a thing like this in a span of one or two hours.
That's because almost all meta frameworks run in Node or something similar, meaning they could access database as much safely as a separate backend,
commincation with which could become a big hurdle.

But Astro is static! say you, but, gladly, there is an option to switch this behaviour in `astro.config.ts`:

```ts title=astro.config.ts 
output: "hybrid",
```

After doing the switch, we go to Node runtime, and generated files start looking like that instead of just a bunch of HTML & CSS:

![Hybrid output file structure](./Node-files.png)

And there opens a possibility to render some parts of our app on demand, real time. What does that mean?
It means everything remains the same, however, now we have an ability to use any backend service freely,
while not opting in to SSR, which would degrade our performance a bit, especially if our hosting machine is not so strong.
All pages still remain static. Sadly, static hostings are gone too, so there is no way to use them with hybrid. But later about deploys!

For interacting with database I have chosen `Prisma`, of course, as I used
it a lot in production and I don't need any performance - just to pat a cat once in a lifetime! (although Prisma is completely scalable
for any sort of project)

For database hosting provider, as my pocket money are my pocket money,
I have chosen to go free: [`Supabase`](https://supabase.com/) offers free `postgres` hosting forever,
if there is no highload.

In development I have crafted very minimal Docker Compose file:

```yml title=compose.yml
services:
  db:
    image: postgres:15.1
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    ports:
      - 5432:5432
    volumes:
      - db_data:/var/lib/mysql
    healthcheck:
      test: ["CMD-SHELL", "mysqladmin ping"]
      interval: 2s
      timeout: 2s
      retries: 10

volumes:
  db_data:
```

It does elevate local postgres with healthcheck and basic env-variables which aren't even dynamic. After that, I added a little bash script
to not be underforming writing all `docker-compose up` commands myself and added `+x` permissions to execute it:

```bash title=startup.sh 
#!/bin/bash

echo "Starting Postgres..."
docker-compose up -d --wait
echo "Postgres started!"

echo "Migrating database..."
pnpm prisma db push
echo "Database migrated!"

echo "Starting server..."
pnpm dev
echo "Server started!"
```

```bash
chmod +x ./startup.sh
```

I also had to finally add `.env` file:

```python
# DATABASE_URL=postgresql://postgres.******@aws-0-eu-central-1.pooler.supabase.com:6543/postgres?pgbouncer=true&connection_limit=1
# DIRECT_URL=postgresql://postgres.******@aws-0-eu-central-1.pooler.supabase.com:5432/postgres?pgbouncer=true

DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:5432/db
DIRECT_URL=postgresql://postgres:postgres@127.0.0.1:5432/db
```

Here, commented-out lines are for connecting to remote supabase instance which I created. You can grab the url in the console.
For Prisma migrations to work with it, it needs two distinct postgres strings: in session & transaction mode, i.e. `DATABASE_URL` and `DIRECT_URL`.
We use `pgbouncer_true` because `stored procedures` do not work with Supabase, and `connection_limit=1` on DATABASE_URL
so there would not be more than one instance of PrismaClient running around.

So, what about the cat? As I got rid of the actions, I had to use `zod` add few server routes, a little abstracted as I wanted to also
record reads and views as well:

```ts title=schemas.ts
import { z } from "astro:schema";

export const postQuerySchema = z.object({
  postId: z.string(),
});

// enum for multiple actions on the post records
export enum PostAction {
  READ = "read",
  LIKE = "like",
  VIEW = "view",
}

export const postActionSchema = z.object({
  postId: z.string(),
  action: z.enum([PostAction.READ, PostAction.LIKE, PostAction.VIEW]),
});
```

```ts title=/api/blog/index.ts
import { db } from "@/lib/db";
import { PostAction, postActionSchema } from "@/lib/schemas";
import type { Post } from "@prisma/client";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library";
import type { APIRoute } from "astro";

// map to increment int fields
const incFieldsSchema: Record<PostAction, keyof Omit<Post, "id">> = {
  [PostAction.READ]: "reads",
  [PostAction.LIKE]: "likes",
  [PostAction.VIEW]: "views",
};

// say that astro should not prerender this server route
export const prerender = false;

export const POST: APIRoute = async ({ request }) => {
  try {
    // parse body with zod
    const body = await request.json();
    const parsedBody = await postActionSchema.safeParseAsync(body);

    if (!parsedBody.success) {
      throw new Error(parsedBody.error.message);
    }

    const { postId, action } = parsedBody.data;

    await db.post
      .update({
        where: { id: postId },
        data: {
          // apply action
          [incFieldsSchema[action]]: {
            increment: 1,
          },
        },
      })
      .catch(async (err) => {
        // Check for "Not Found" error and create the record if it does not exist
        if (
          err instanceof PrismaClientKnownRequestError &&
          err.code === "P2025"
        ) {
          return db.post.create({
            data: {
              id: postId,
              ...{ [incFieldsSchema[action]]: 1 },
            },
          });
        }

        console.log(err);
      });

    return new Response(JSON.stringify({ success: true }));
  } catch (error) {
    console.log(error);
    return new Response(JSON.stringify({ success: false }));
  }
};
```

And here I get the post by id:

```ts title=/api/blog/[postId].ts
import { db } from "@/lib/db";
import { postQuerySchema } from "@/lib/schemas";
import type { Post } from "@prisma/client";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library";
import type { APIRoute } from "astro";

export const prerender = false;

export const GET: APIRoute = async ({ params }) => {
  const result = await postQuerySchema.safeParseAsync(params);

  if (result.error) {
    throw new Response(JSON.stringify({ error: result.error.message }), {
      status: 400,
    });
  }

  const {
    data: { postId },
  } = result;

  const post =
    (await db.post
      .findUnique({
        where: { id: postId },
      })
      .catch((e) => {
        console.log(e);
      })) ??
    ({
      // and return default post if it does not exist
      id: postId,
      views: 1,
      reads: 0,
      likes: 0,
    } satisfies Post);

  return new Response(JSON.stringify(post));
};
```

I return default post instead of creating because I dont want to deal with race that happens when page loads
and info gets requested & 1 view pushed to db. Well, I may as well might have created all the posts myself,
but then in dev mode, and if something happens to db, I would have to recreate them, which is not cool if I would have
10 or more of them.

For interaction I also created file `lib/api.ts` and put all requests there behind an `export` service:

```ts
const getPost = async (postId: string) => {
  return fetch(getAbsoluteUrl(`/api/blog/${postId}`)).then<Post>((res) =>
    res.json(),
  );
};

const readPost = async (postId: string) => {
  return fetch(`/api/blog`, {
    method: "POST",
    body: JSON.stringify({
      postId,
      action: PostAction.READ,
    }),
  }).then<{ success: boolean }>((res) => res.json());
};

// two other actions

export const postsApi = {
  getPost,
  readPost,
  viewPost,
  likePost,
} as const;
```

And used it like so:

```ts
postsApi.likePost(slug).then(() => {
      count.textContent = String(Number(count.textContent) + 1);
});
```

The rest of the code is pretty much the same for the button that scrolls upwards.

The only real difference is that I used `Audio` api to make him purr, but just by importing the sound and playing it:

```ts
const audio = new Audio("/sounds/cat.mp3");
audio.play();
```

Glad that Astro handles assets this easily even in script tags with underlying `Vite`.

Now, let's get to deploying and adapting database to real world.

## Rocket cake

At first I wanted to deploy to `Github pages`, but then I decided on using a database, so static hostings were out,
because they don't support running Node, but rather just deliver static files through their `Web server` like `Nginx` or `Apache`.

The only cool Node-based (actually `serverless`) hosting I knew was [`Vercel`](https://vercel.com/home) which supports using Astro in all modes.

I love Vercel because how easy it is to deploy: you push to repo, link the repo and it all just runs your build command,
deploys to the internet in just few seconds, provides you with a free domain (mine has got its full name unchanged),
free ssl certificate and overall smooth experience.

To build on Vercel I had to add an `adapter` - Astro uses them to determine which build artifacts and how it needs to generate for it to be runnable. [Here's the full list of adapters](https://astro.build/integrations/?search=&categories%5B%5D=adapters), I've grabbed `@astro/vercel` and added it like so:

```ts title=astro.config.ts
import vercel from "@astrojs/vercel/serverless";

// in config
adapter: vercel(),
```

That wasn't all with adapters - I had to also add `@astrojs/node` one because Vercel adapter doesn't work in `preview mode` in local environment, so I wouldn't be able to run production code myself. I did it like so:

```ts title=astro.config.ts
import node from "@astrojs/node";
import vercel from "@astrojs/vercel/serverless";

// config
adapter: process.env.IS_LOCAL
? node({
	mode: "standalone",
  })
: vercel(),
```

Here, I use `process.env.IS_LOCAL` environment variable which determines whether Astro would use Node or Vercel adapter.
I provide variable like so:

```json title=package.json
"preview:local": "IS_LOCAL=true astro build && IS_LOCAL=true astro preview",
```

Since both commands must be run with the same adapter, I add the variable to each.

I also had to add environment variables previously specified in the `.env` to Vercel configuation like so:

![Vercel environment config](./Vercel-env.png)

And create a migration file against my local database:

```bash
pnpm prisma migrate dev
```

And changing the `build` command:

```json
"build": "pnpm prisma generate && astro check && pnpm prisma migrate deploy && astro build",
```

to let Prisma generate types before the typecheck, then execute migrations on
production database and lastly build the server all in one command.

That's it!

## Gordon Ramsay show

The last part of this article 's gonna be about my dark path of SEO learner.
I had almost non-existent knowledge on how to make website work.
This section would be more about what final thoughts about best practices on making a blog I have after this journey.

I was intersted to dive deep into documentation for SEO.
For a long time I thought it to be very abstract and far away from me,
but as I'd seen my knowledge gap, I wanted to close it, just a bit. So, I started reading.

I read, and read, and read. One link led to another, led to another, led to another, 
and I was down to a rabbit hole without any big picture.
I have tried to know everything at once and it was a mistake!
I have learned things well only by trying to figure out what worked for me, which may not be ideal real-world representation,
but it is a part of it. I will see how it works for others later. So, a clear lesson here is:

> Overview a new knowledge and try it out first, then go deep.

I have seen sites made purely for SEO optimization or AI generated, and it was horrible.
Infinite bullet-lists, topic inflating and repeating countless times swapping few words between repetitions. 
So, here's what I think makes the blog nice:

- Proper performance and adaptivity. It should not memory leak, it should not load 10 mb of javascript.
It should load important content fast and first! And it should show this content well. It should also be accessible, which means:
  
  - HTML is semantic: you use `<section>`, `<main>`, `<aside>`, `<nav>` and other tags so that users
  with screenreaders can navigate through them
  - Every button is tabbable, which means if you make a styled `<div>` for a button, at least add `role="button"` and
  `tabindex="0"` to it. In modals, use `<dialog>` or other `focus trap` alternatives,
  so that users wouldn't get leaked to other page while the modal closes the view. 
  - Make everything readable: add proper contrast so that no content would be lost,
  style typography to not be too wide or too small.
  With Daisy it is easy as there's prebuilt themes and `@tailwind/typography` at your service.

So `it may as well run on the microwave by a blind man in his royal castle ten thousands kilometers away while he streams
it to his phone with 1kb/s internet, if he uses that for reading tech articles.` And the web allows you to do so, within reason.
  
- Content should be carefully crafted and revised multiple times.
This does not mean to think about every word you write, but actually write and think about what your content
should like if you wanted it to be good. Some people AI can write for them - it's cool, but you should also write yourself,
improve and cultivate style and taste. `If you can't think of something to write about something, then you should not be writing`.
Do not write just for the sake of showing anything at all. At least tell how you feel.
  
- There should be important meta tags like `<title>` and `<description>`.
Also, `OpenGraph` and its Twitter implementation is nice for other people to stumble upon your article.
These are added with `<og:[image]>` tags, for example: `<meta property="og:title"> My great post! </meta>`. I also add these tags:

```html
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="generator" content={Astro.generator} />
    <link rel="canonical" href={canonicalURL} />
```

- You should use `tools for tracking performance`, like `https://pagespeed.web.dev/` or Chrome Lighthouse Report in developer tools.
It would pinpoint website's weak spots so you could fix them.
But, `do not overdo this`. Few points may get you closer to 100 and 100's will get you dopamine surge, but..
  
- `Add RSS feed.` I like them. And they are everywhere.
Its not a mail newsletter in a sense that its not so advanced that you would track your reader's email and audience count,
but it is simple and `many people use them to get updates` about your blog.
  
-  `Spend time delivering features and gathering feedback`. 
It is the most important step. I've been making this blog for a week and couldn't stop unless I told myself to stop repeatedly,
and I'm still doing this üòá You are making content for others, and as you're writing and (of course you do) putting yourself
in shoes of your audience, `you must give them something worthwhile instead of polishing the button for 10 hours`
that would break on the next commit anyway because you're human.
If something breaks, fix it, learn how it broke. Make your app better. In a sense this blog made me a better developer,
because my users or business' users would not profit from another iteration of theme change, `they profit from content`.
  
- `Tell the truth`. Do not pamper good stuff, but also do not overshadow anything. Bring the real life, your experience to others,
`give out what you have earned working hard, so others would not sweat as much`.
Share your feelings and views to find those who will find solace in your words.
For example, after [this Daniel Roe's short story](https://roe.dev/blog/little-oak)
I got pretty sad, but understood many things. So he healed me a bit, even though he didn't know me.
That's probably because he healed himself with it at the time of writing, and that's what makes this post real.


And well, without doing the good, you would have bad.
Of course, if you add white links on white background and give them urls to ten thousand pages about taking the dump
and add a hundredth theme in your selector so that your page loads three seconds, it will be even worse üëÅÔ∏è

## Afterparty

In the end, I want to say that making this blog and writing this article was quite unveiling to me in many senses.
I had seen once again in much bigger light that my obssessions about performance and idealism take the best of me.
All the preliminary optimizations, utterly nonsense Google Docs surfs for hours trying to conceal my procrastination from myself.

After that, I have grown surer that building something and investing yourself in life as a participant
makes you better human being just because you have to see who you really are, which you maybe won't because
you don't want to and there's nothing to push you to it. Setting goals, keeping promises given to yourself,
following the idea that your mind originated to its end - that's what I've been lacking greatly as a developer. 

I had worked almost a year in a company where the only metric for success was how many features I make per how many hours of work.
I have tried reading books, making some apps, but infinitely, I have become a slouch who was making forms over and over and
over again. Of course, there were challenges, and I have grown from them too, but while I didn't see who am I turning into -
folder mover (architect), button painter (ui designer), frameworkista (qualified specialist), I actually became worse.
When simplicity was required, I was trying to over-complicate, because I thought that's what smart developers do. Like that picture:

![Simplicity's Bell curve](./Simplicity.webp)

Astro is a great framework and a good learning resource for those who may find themselves lost in all these terms -
SPA, SSR, SSG, ISR and so on. If you open the docs open-minded and build something yourself,
try to see what tools you use, what code you write and how it actually works under the hood,
you will feel much better. Don't hurry - and it will pay out in the end üê± Thanks for reading!
