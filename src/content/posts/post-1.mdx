---
slug: "post-1"
title: "Crafting cool code blocks"
description: "Learn how to style code blocks from Markdown and MDX with Astro, Shiki, Remark and Rehype."
date: 2024-06-10
image: "./img.jpg"
imageAlt: "A dog wearing a pair of shoes."
tags: ["astro", "shiki", "markdown", "parsing", "css"]
---

```ts title=hello.ts /Hello/ {"1: Hello world!":5-6} blurredLines={1-3,2-5,7-9,5,6}
console.log("Hello, world!");
console.log("Hello, world!");
console.log("Hello, world!");
console.log("Hello, world!");

console.log("Hello, world!");
```

## Nuxt.js

`Nuxt.js` is a powerful framework built on top of `Vue.js` that simplifies the development of server-rendered applications. It provides a robust architecture for building universal applications, which means that the same code can run on both the client and the server. This capability enhances performance and improves SEO, as search engines can easily crawl the pre-rendered pages.

\\

One of the standout features of `Nuxt` is its file-based routing system. By simply creating a new `.vue` file in the `pages` directory, developers can automatically generate routes without the need for additional configuration. For example, if you create a file named `about.vue` in the `pages` folder, it will automatically be accessible at `/about`.

\\

Another significant aspect of `Nuxt` is its support for `Vuex`, which is a state management pattern and library for `Vue.js` applications. `Nuxt` integrates `Vuex` seamlessly, allowing developers to manage the application state efficiently. This is particularly useful in larger applications where managing state can become complex.

\\

To illustrate how easy it is to get started with `Nuxt`, here’s a simple example of creating a basic `Nuxt` application:

```bash
npx create-nuxt-app my-nuxt-app
```

This command sets up a new `Nuxt` project with a default configuration. You can then navigate into the project directory and run the development server:

```bash
cd my-nuxt-app
npm run dev
```

\\

Once the server is running, you can access your application at `http://localhost:3000`. The default template includes a few pages and components, showcasing how `Nuxt` organizes files and directories.

\\

In conclusion, `Nuxt.js` offers a streamlined approach to building applications with `Vue.js`, enhancing both performance and developer experience. Its automatic routing, server-side rendering, and integration with `Vuex` make it a compelling choice for developers looking to create modern web applications.

```ts title=hello.ts /Hello/ {"1: Hello world!":5-6} blurredLines={1-3,2-5,7-9,5,6}
console.log("Hello, world!");
console.log("Hello, world!");
console.log("Hello, world!");
console.log("Hello, world!");

console.log("Hello, world!");
```

## Nuxt.js

`Nuxt.js` is a powerful framework built on top of `Vue.js` that simplifies the development of server-rendered applications. It provides a robust architecture for building universal applications, which means that the same code can run on both the client and the server. This capability enhances performance and improves SEO, as search engines can easily crawl the pre-rendered pages.

\\

One of the standout features of `Nuxt` is its file-based routing system. By simply creating a new `.vue` file in the `pages` directory, developers can automatically generate routes without the need for additional configuration. For example, if you create a file named `about.vue` in the `pages` folder, it will automatically be accessible at `/about`.

\\

Another significant aspect of `Nuxt` is its support for `Vuex`, which is a state management pattern and library for `Vue.js` applications. `Nuxt` integrates `Vuex` seamlessly, allowing developers to manage the application state efficiently. This is particularly useful in larger applications where managing state can become complex.

\\

To illustrate how easy it is to get started with `Nuxt`, here’s a simple example of creating a basic `Nuxt` application:

```bash
npx create-nuxt-app my-nuxt-app
```

This command sets up a new `Nuxt` project with a default configuration. You can then navigate into the project directory and run the development server:

```bash
cd my-nuxt-app
npm run dev
```

\\

Once the server is running, you can access your application at `http://localhost:3000`. The default template includes a few pages and components, showcasing how `Nuxt` organizes files and directories.

\\

In conclusion, `Nuxt.js` offers a streamlined approach to building applications with `Vue.js`, enhancing both performance and developer experience. Its automatic routing, server-side rendering, and integration with `Vuex` make it a compelling choice for developers looking to create modern web applications.

## Введение

На данный момент в мире фронтенд разработки накопилось много разных технологий и вместе с ними подходов к тому, как нужно разрабатывать приложения, которые становятся сложнее и сложнее с каждым днем - `React`, `Vue`, `Svelte` и так далее. Вместе с каждой из этих технологий рядом обычно следует мета-фреймворк - инструмент и большая экосистема библиотек, которые создают юзеры опенсорс пространства. Для `React` это `Next.js`, для `Svelte` - `SvelteKit`, а для `Vue` - `Nuxt`. Сегодняшняя статья будет именно про него.

Почему `Vue` и `Nuxt`? Эван Ю, создатель `Vue`, многое почерпнул из работы в Google и создал более тонкую версию `Angular` - что-то похожее на `React`, менее гибкий, но при этом намного более приятный при разработке. Встроенная оптимизация ререндеринга `Virtual DOM`, классные API в отсутствии `JSX` и широкая экосистема позволяют `Vue` быть идеальным решением между простотой `React` и громоздкостью того же `Angular`. `Vue` сильно упрощает работу со стейтом и рендерингом, часто не позволяя выстрелить себе в ногу, как это делает `React`, что также делает его классным инструментом для новичков. Используя `Vue`, можно научиться всем основным принципам современного фронтенда без особой головной боли.

`Nuxt` же дополняет `Vue` в вопросах выбора технологии для маленьких и средних проектов - он предоставляет полную поддержку `SSR` из под коробки, новомодный файловый роутер и неплохую возможность построить бэкенд прямо из нашего приложения с помощью серверных роутов. По ходу этой статьи мы полностью задействуем все возможности `Nuxt` и построим небольшую архитектуру проекта.

## Структура статьи

В этой статье мы напишем среднего размера Fullstack приложение публичных заметок - Deep Thoughts (Глубокие Мысли). В приложении можно будет оставлять публичные записи, которые будут отображаться на главной странице. Мы будем использовать библиотеку `shadcn/vue` в качестве юайкита, а также рассмотрим решение актуальных проблем ее интеграции с `Nuxt`. Напоследок, мы будем сохранять все данные в реальную базу данных `MySQL` и работать с ней через `Prisma`. Во время разработки мы будем использовать `Docker Compose`, а в конце статьи захостим базу на серверах `Timeweb` и задеплоим проект через `Dockerfile`.

По ходу написания приложения я буду простым языком объяснять свой подход к решению встающих перед нами проблем с примерами, а также давать ссылки на более развернутое решение, если они будут нужны. С этим вы также научитесь быстро решать проблемы, если они возникнут у вас при разработке. Если требуется какая-либо помощь, можете написать в комментарии! Я с радостью помогу вам.

## Подготовка проекта

Для начала давайте инициализируем новый проект на `Nuxt`. Для этого используем следующую команду:

`npx nuxi init deep-thoughts`

![[Pasted image 20240823075045.png]]

В качестве пакетного менеджера я выбираю стандартный `npm`, но вы можете выбрать любой на ваш вкус.

#### Установка и кастомизация shadcn

Теперь давайте заведем на проект наш юайкит. Актуальный гайд по установке можно всегда посмотреть по ссылке: https://www.shadcn-vue.com/docs/installation/nuxt.html.

Для начала давайте обсудим, что такое `shadcn`. Изначально этот юайкит появился в экосистеме `React`. Его создал пользователь `shadcn` с уникальным подходом к тому, как должны распространяться юайкиты. Вместо того, чтобы завернуть все свои компоненты в библиотеку-npm пакет, shadcn использовал дополнительный `CLI` (Command-Line Interface), который позволяет любому скачать полноценный компонент прямо в свой проект без каких-либо зависимостей (помимо общих библиотек экосистемы, вроде `react-hook-form`).

Многим полюбился этот подход и библиотека приобрела огромную популярность. Позже ее портировали для `Svelte` и `Vue` практически в полном виде. Порт для `Vue` использует под капотом библиотеку `radix-vue`, для форм же используется `vee-validate`.

Продолжим. Для инициализации библиотеки, введем пару команд:

`npm install -D typescript` для решения общих проблем с `Nuxt` и `Typescript`

`npx nuxi@latest module add @nuxtjs/tailwindcss` - установка модуля `Tailwind` для `Nuxt`. Если вы не знакомы с `Tailwind`, рекомендую ознакомиться с этой технологией тут: https://tailwindcss.com

`npx nuxi@latest module add shadcn-nuxt` - установка модуля `shadcn`

`npx shadcn-vue@latest init` - запуск инициализации `CLI` `shadcn`. В процессе выбираем все дефолтные значения. В качестве фреймворка, конечно же, `Nuxt`.

В итоге мы должны получить такую структуру папок:

![[Pasted image 20240823081139.png]]

Также давайте создадим еще один файл и назовем его `main.css`:

```css
@import "tailwind.css";

html,
body {
  height: 100%;
  width: 100%;
}

#__nuxt {
  height: 100%;
}
```

Он импортирует созданный `shadcn` файл `tailwind.css`, в котором добавляются дефолтные импорты `Tailwind` и переменные темы, а также добавит немного стилей для того, чтобы растянуть `<body>` на весь экран.

Чтобы `Nuxt` учитывал наш главный CSS файл, мы должны указать его в `nuxt.config.ts`:

```ts
css: ["assets/css/main.css"],
```

Теперь давайте добавим на проект первых компонент - обычную кнопку и убедимся, что все работает как нужно:

`npx shadcn-vue@latest add button`

Далее создадим папку `pages`, а в ней файл `index.vue` с дефолтным шаблоном для `Vue`:

```vue
<script setup lang="ts"></script>

<template></template>
```

Также нам нужно будет изменить файл `app.vue`. Это корневой файл приложения. Сейчас в нем следующая запись:

```vue
<template>
  <div>
    <NuxtRouteAnnouncer />
    <NuxtWelcome />
  </div>
</template>
```

Нам же нужно будет убрать приветственный экран `Nuxt` и привести все к такому виду:

```vue
<template>
  <NuxtLayout>
    <NuxtRouteAnnouncer />
    <NuxtPage />
  </NuxtLayout>
</template>
```

Это позволит нам использовать файловый роутер и лейауты (о них позже).

Давайте добавим на страницу `index.vue` компонент кнопки, который авто-импортируется с помощью `Nuxt`:

```vue
<template>
  <Button> Hello World! </Button>
</template>
```

Почитать о авто-импортах можно тут: https://nuxt.com/docs/guide/concepts/auto-imports. Если вы хотите как-то выделить компоненты из юайкита, вы добавить им префикс в `nuxt.config.ts`:

```ts
shadcn: {
    prefix: "prefix",
  },
```

Запускаем сервер командой:

`npm run dev`

и на выходе получаем нашу долгожданную кнопку:

![[Pasted image 20240823082722.png]]

Напоследок, давайте добавим все необходимые для нашего проекта компоненты юайкита. Сделаем мы это заранее и сразу же устраним проблему, которая обязательно возникнет при этом. Введем следующую команду:

`npx shadcn-vue@latest add card form input label textarea`

`CLI` добавит на наш проект компоненты карточки, формы, полей ввода и лейбла, а также установит библиотеку `vee-validate`.

Теперь давайте попробуем использовать компонент формы, согласно документации библиотеки: https://www.shadcn-vue.com/docs/components/form.html:

```vue
<Form>
    <FormField name="hello" v-slot="{ componentField }">
      <FormItem>
        <FormLabel> Hello! </FormLabel>
        <FormControl>
          <Input v-bind="componentField" />
        </FormControl>
        <FormDescription />
        <FormMessage />
      </FormItem>
    </FormField>
</Form>
```

Инпут появится на экране, но в консоли будут следующие ошибки:

![[Pasted image 20240823084054.png]]

Все потому, что компонент `FormItem` использует хук `useId` из `radix-vue`, который создает мисмэтч (mismatch) при `SSR` в `Nuxt`, потому что он не адаптирован для серверного рендеринга. Для исправления этой ошибки давайте добавим специальную обертку из `radix-vue` в `app.vue` как предлагают тут: https://github.com/radix-vue/radix-vue/issues/577#issuecomment-1980983686. Она заменит имплементацию `radix-vue` на авто-импорт `Nuxt`:

```vue
<script lang="ts" setup>
import { ConfigProvider } from "radix-vue";

const useIdFunction = () => useId();
</script>

<template>
  <ConfigProvider :use-id="useIdFunction">
    <NuxtLayout>
      <NuxtRouteAnnouncer />
      <NuxtPage />
    </NuxtLayout>
  </ConfigProvider>
</template>
```

Ошибка ушла 🎉:

![[Pasted image 20240823090848.png]]

Теперь все готово для дальнейшей работы с проектом. Перейдем к базе данных!

## Добавление базы данных

Теперь давайте добавим в наш проект базу данных и `Prisma`. В качестве базы данных мы будем использовать `MySQL`, который развернем локально с помощью `Docker Compose`.

Немного о самом докере. `Docker` - крайне распространенная технология контайнеризации окружений. Она помогает разработчикам делиться кодом друг с другом, переиспользуя точные копий окружений, чтобы не вставал конфликт о том, что у вас на компьютере все работает, а на проклятом облачном сервере Digital Ocean совсем не хочет. В нашем случае мы будем использовать `Docker` как для разработки - подтянем образ `MySQL`, чтобы не устанавливать `MySQL` на сам компьютер. Позже мы напишем `Dockerfile`, с помощью которого наш проект будет разворачиваться через `Timeweb`.

Чтобы использовать `Docker Compose`, нужно установить сам `Docker`. Инструкции вы можете найти в документации по ссылке: https://docs.docker.com/engine/install/ - выберите вашу операционную систему и следуйте руководству.

Как только установите `Docker`, давайте напишем файл `compose.yml`, который будет подтягивать образ `mysql`:

```yml
services:
  db:
    image: mysql:8.3
    restart: always
```

Далее, давайте добавим переменные окружения, чтобы управлять паролем `root` пользователя `mysql` и выбирать базу, с которой будем работать. Для этого добавим файл `.env` со следующими переменными:

```
DB_DATABASE=app
DB_PASSWORD=randompassword4000
```

и используем их в `compose.yml`:

```yml
services:
  db:
    image: mysql:8.3
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_DATABASE: ${DB_DATABASE}
```

Далее, нужно будет привязать данные, которые будет использовать контейнер, к данным нашего компьютера. Это нужно для того, чтобы после перезагрузки контейнер сохранял все, что было в него добавлено. Для этого добавим следующие записи:

```yml
services:
  db:
    image: mysql:8.3
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_DATABASE: ${DB_DATABASE}
    volumes:
      - db_data:/var/lib/mysql

volumes:
  db_data:
```

`volumes` под `db` означает: сохраняй в папку `db_data` на моем компьютере все, что лежит в папке `/var/lib/mysql` в контейнере. Запись ниже дает докеру знать, что у нас есть `volume` с таким именем. Он будет использовать дефолтный конфиг сохранения для `db_data`, чего нам достаточно.

Далее, чтобы наше приложение смогло взаимодействовать с базой, нужно пробросить порты из контейнера наружу. Делается это с помощью записи:

```yml
db:
	ports:
      - "3306:3306"
```

которая означает, что порт слева (на нашем компьютере) будет смотреть на порт справа (в контейнере) и наше приложение сможет воспользоваться базой через порт 3306, который соответствует порту 3306 в контейнере.

Напоследок, добавим проверку статуса запуска контейнера - `healthcheck`. Это нужно для того, чтобы знать, когда база уже готова принимать запросы и можно запустить приложение, а когда нет. По сути `healthcheck` будет состоять в том, что в контейнере будет выполняться команда `mysqladmin ping` в определенном интервале, что даст докеру знать, "здоров" контейнер или нет. Финальная запись `compose.yml`:

```yml
services:
  db:
    image: mysql:8.3
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_DATABASE: ${DB_DATABASE}
    volumes:
      - db_data:/var/lib/mysql
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD-SHELL", "mysqladmin ping"]
      interval: 2s
      timeout: 2s
      retries: 10

volumes:
  db_data:
```

Попробуем запустить `Docker`:

`docker compose up`

Если видите такую запись:

![[Pasted image 20240823130732.png]]

значит все хорошо и контейнер успешно запущен 🏋️

## Инициализация Prisma

Пару слов о `Prisma`. `Prisma` - одна из самых популярных `ORM` (Object-Relational Mapper) для `Node.js`. У этой библиотеки огромное комьюнити и годы разработки и пофикшенных багов позади - можно считать ее надежным и полноценным инструментом. `ORM` понадобится нам для того, чтобы проще взаимодействовать с базой данных, не мучаться с санитизацией SQL-запросов, поддерживанием состояния базы данных и миграций, написанием и последующей поддержкой своих запросов и типов к ним. `Prisma` имеет крайне дружелюбное API, с помощью которого можно писать простые приложения с базами данных даже без особого знания SQL.

Давайте добавим `Prisma` на проект. Для этого установим две библиотеки:

`npm i prisma -D`
`npm i @prisma/client`

Первая - это `CLI` `Prisma`, с помощью которого мы инициализируем проект, будем добавлять миграции, чтобы позже иметь возможность полностью восстановить структуры базы данных по щелчку пальцев, а также применять изменения структуры напрямую к базе. Вторая - это клиент для `Prisma`, с помощью которого мы будем делать сами запросы в коде.

Далее напишем:

`npx prisma init`

Это создаст папку `prisma` в корне проекта и файл `schema.prisma` внутри. Немного изменим структуру файла, чтобы она была такой:

```json
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

После этого давайте добавим переменную `DATABASE_URL` в наш `.env` файл:

```
DATABASE_URL=mysql://root:${DB_PASSWORD}@localhost:3306/${DB_DATABASE}
```

Здесь мы используем интерполяцию переменных, которые добавили ранее, чтобы при их изменении мы могли не беспокоиться о синхронизации между ними.

Далее добавим в схему `Prisma` нашу модель мысли (Thought):

```json
model Thought {
  id       Int    @id @default(autoincrement())

  username String
  text String @db.VarChar(256)

  createdAt DateTime @default(now())
}
```

К модели `Prisma` создаст таблицу в базе данных с указанными полями. `id` будет числовым и с каждой записью будет увеличиваться на 1 с помощью `@default(autoincrement)`. К полю `text` мы добавим `@db.VarChar(256)`, чтобы оно могло хранить 256 символов, а не 191, как оно хранило бы просто с типом `String`. `createdAt` будет выставляться автоматически при создании записи.

Наконец, убедимся что контейнер запущен в одном из терминалов и, перейдя в другой терминал выполним команду:

`npx prisma db push`

![[Pasted image 20240823132626.png]]

Если ваш вывод похож на этот, то мы успешно обновили базу данных в `Docker` 💽

Для улучшения DX (Developer Experience), теперь можно написать небольшой скрипт для запуска проекта в одну команду. Он будет поднимать контейнер с базой данных, накатывать актуальные миграции и запускать проект:

`startup.sh`

```bash
echo "Запускаем докер 🐋"
docker compose up -d --wait # Флаг -d (detached) запускает docker compose в бэкграунде. --wait обеспечивает готовность контейнера и передает контроль обратно скрипту, чтобы выполнять миграции только после того, как база будет готова

echo "Накатываем миграции 🛠"
npx prisma db push

echo "Запускаем приложение 🚀"
npm run dev
```

![[Pasted image 20240823133104.png]]

Все работает 👍

Наконец, давайте добавим инициализацию клиента `Prisma` в папку `server/db`:

`index.ts`

```ts
import { PrismaClient } from "@prisma/client";

const createPrisma = () => {
  return new PrismaClient();
};

declare const globalThis: {
  db: ReturnType<typeof createPrisma>;
} & typeof global;

export const db = globalThis.db ?? createPrisma();

if (process.env.NODE_ENV !== "production") globalThis.db = db;
```

Метод `createPrisma` просто возвращает инстанс класса `PrismaClient`, который сгенерировал `CLI` призмы. Далее идет объявление глобальной переменной `db` и ее инициализация и переинициализация в случае, если окружение не является продовым. Это сделано для того, чтобы при `Hot-Reload` сервера `Nuxt` не создавал новый инстанс `PrismaClient`, а переопределял текущий, и всегда использовал только один-единственный.

## Интерфейс формы отправки

Далее, давайте напишем форму создания _Глубокой_ мысли.

Для валидации форм мы будем использовать `zod` (https://github.com/colinhacks/zod), популярную библиотеку для валидации данных. Также `zod` полностью интегрирован с `TypeScript` и `vee-validate`. Когда мы устанавливали компонент `form` из `shadcn`, `CLI` автоматически установил библиотеку `zod` и адаптер для `vee-validate` - `@vee-validate/zod` на наш проект.

Так как мы пишем Fullstack приложение, чуть позже мы добавим логику валидации данных на сервере, поэтому давайте создадим отдельную папку `schemas` в корне проекта для хранения валидационных схем `zod`. Добавим туда файл `thought.ts`, в котором объявим простую схему `zod` и экспортируем ее и `TypeScript` интерфейс, который генерирует `zod` через `utility-тип` `z.Infer<T>`:

`thought.ts`

```ts
import { z } from "zod";

export const CREATE_THOUGHT_MAX_LENGTH = 200; // эту константу используем в форме

export const createThoughtSchema = z.object({
  text: z
    .string({
      message: "Введите текст мысли",
    })
    .min(1, {
      message: "Введите что-то!",
    })
    .max(CREATE_THOUGHT_MAX_LENGTH, {
      message: `Максимальная длина текста ${CREATE_THOUGHT_MAX_LENGTH} знаков`,
    }),
  name: z
    .string({
      message: "Введите свое имя",
    })
    .max(50, {
      message: "Максимальная длина имени 50 знаков",
    }),
});

export type CreateThoughtSchema = z.infer<typeof createThoughtSchema>;
```

Теперь давайте напишем логику формы в папке `components/thought/form`:

`ThoughtForm.vue`

```vue
<script setup lang="ts">
// импортируем схему, типы и методы из vee-validate
import {
  CREATE_THOUGHT_MAX_LENGTH,
  createThoughtSchema,
  type CreateThoughtSchema,
} from "~/schemas/thought";

import type { ThoughtInputRef } from "./props";

import { toTypedSchema } from "@vee-validate/zod";
import { useForm } from "vee-validate";

// иницилазируем Props, чтобы потом отобразить ошибку
interface Props {
  error?: string;
}

defineProps<Props>();

// инициализуем emit, чтобы прослушивать submit в компоненте-родителе
const emit = defineEmits<{
  (event: "submit", data: CreateThoughtSchema): void;
}>();

// инициализируем форму vee-validate
const form = useForm({
  validationSchema: toTypedSchema(createThoughtSchema),
});

const handleSubmit = form.handleSubmit((data) => {
  emit("submit", data);
});
</script>
```

Структура компонента будет такой: мы используем компонент `Card` в качестве обертки, сделаем два поля, как в схеме: имя пользователя и текст мысли. Текст мыслей мы реализуем с помощью `Textarea`. При этом мы добавим счетчик символов и ограничим количество символов константой, которую объявили в файле со схемами. Еще, мы хотим чтобы при нажатии `Shift+Enter`, сообщение отправлялось без нажатия на кнопку - для этого мы привяжем слушатель `@keydown.enter.prevent` с чеком на `event.shiftKey`. Внизу карточки мы сделаем вывод ошибки - красного текста, если она будет прокинута снаружи. Все это выглядит примерно так:

```vue
<template>
  <Card>
    <CardHeader class="p-5 pb-0">
      Поделитесь своей глубокой мыслью!
    </CardHeader>
    <CardContent class="p-5">
      <form
        class="gap-2 flex flex-col"
        @submit="handleSubmit"
        @keydown.enter.prevent="
          (event) => {
            if (event.shiftKey) {
              handleSubmit();
            }
          }
        "
      >
        <FormField
          v-slot="{ componentField }"
          name="name"
          :validate-on-blur="false"
        >
          <FormItem>
            <FormControl>
              <Input v-bind="componentField" placeholder="Ваше имя" />
            </FormControl>

            <FormMessage />
          </FormItem>
        </FormField>

        <FormField
          v-slot="{ componentField }"
          name="text"
          :validate-on-blur="false"
        >
          <FormItem>
            <FormControl>
              <div class="relative">
                <Textarea
                  :maxlength="CREATE_THOUGHT_MAX_LENGTH"
                  placeholder="Давайте же..."
                  v-bind="componentField"
                  class="resize-none"
                />
                <div
                  class="absolute bottom-1 right-2 flex items-center gap-2 z-5"
                >
                  {{ componentField.modelValue?.length || 0 }}/{{
                    CREATE_THOUGHT_MAX_LENGTH
                  }}
                </div>
              </div>
            </FormControl>

            <FormMessage />
          </FormItem>
        </FormField>

        <Button type="submit" class="mt-2">Отправить!</Button>

        <p v-if="error" class="text-md font-bold text-red-500">
          {{ error }}
        </p>
      </form>
    </CardContent>
  </Card>
</template>
```

Давайте посмотрим на наш компонент:

```vue
<div class="max-w-md mx-auto mt-4">
    <ThoughtForm error="Error" />
</div>
```

![[Pasted image 20240823123947.png]]

Под конец, давайте добавим возможность очищать форму по нашему желанию в компоненте родителя. Так, мы сможем очищать форму не сразу после отправки, а только если отправка была успешной, чтобы пользователь смог использовать то, что уже написал.

Такой функционал можно реализовать с помощью метода `defineExpose`. Для этого создадим в папке `components/thought/form` файл `types.ts`:

```ts
export interface ThoughtFormRef {
  handleResetForm: () => void;
}
```

И в самом компоненте добавим импорт:

```ts
import type { ThoughtFormRef } from "./types";
```

И `defineExpose`:

```ts
defineExpose<ThoughtInputRef>({
  handleResetForm: () => {
    form.resetForm();
  },
});
```

Теперь нам нужно добавить `ref` в компоненте-родителе:

```vue
<script setup lang="ts">
import { type ThoughtFormRef } from "~/components/thought/form/types";

const formRef = ref<ThoughtFormRef>();
</script>

<template>
  <div class="max-w-md mx-auto mt-4">
    <ThoughtForm error="Error" ref="formRef" />
  </div>
</template>
```

И сторонюю кнопку, которая будет сбрасывать состояние формы:

```vue
<Button @click="formRef?.handleResetForm()"> Сбросить </Button>
```

Введем что-то:

![[Pasted image 20240823124627.png]]

И нажмем на кнопку:

![[Pasted image 20240823124640.png]]

Все работает 🎉

## Серверная логика

Теперь давайте напишем логику на сервере, которая будет принимать запросы с формы и сохранять полученные данные в базу данных, а также добавим возможность получать все сохраненные мысли.

Подробнее узнать о том, как работает бэкенд-составляющая `Nuxt` можно здесь: https://nuxt.com/docs/getting-started/server. Вкратце, при инициализации проекта также создается папка `server`. В ней мы можем создать папку `routes` или `api`, в которых можем создавать папки и файлы для REST API. По сути, в `Nuxt` можно реализовать мини-API вроде `Express`, не запуская дополнительных серверов.

`Nuxt` основан на сервере `Nitro`. `Nitro` - обертка для HTTP фреймворков вроде `h3`. Обе технологии являются частью экосистемы `unjs`. Например, мы также будем использовать утилиту `$fetch` из библиотеки `unjs/ofetch`, которая заменяет `fetch` браузера для большей совместимости. В экосистеме много других модулей, посмотреть их можно тут: https://github.com/unjs

Для того, чтобы создать API с `Nitro`, создадим файл в папке `server/routes/thought`:

`index.get.ts`

```ts
export default defineEventHandler(async (event) => {
  return "Hello world!";
});
```

и, запустив проект, перейдем на `url` `/thought`:

![[Pasted image 20240823135239.png]]

Мы написали первый API `handler`(ручку)! 🐒

Файловая система в папке `server/routes` работает также, как файловый роутер в `pages`: мы можем создавать API ручки с помощью названия папок и файлов. Суффикс `get` означает, что по роуту `/thought` будет работать только `GET` запрос. Например, если мы изменим суффикс на `post`, то в браузере увидим страницу 404:

![[Pasted image 20240823135543.png]]

Метод `defineEventHandler` принимает в себя колбек для роута, в котором доступна переменная `event`. `event` можно использовать очень многими способами - подробнее о нем можно прочитать в документации. В нашем же случае мы будем парсить `body`, чтобы получить данные в `post` запросе.

Давайте добавим в файл `index.post.ts` логику создания мысли:

```ts
import { createThoughtSchema } from "~/schemas/thought";
import { db } from "~/server/db";

export default defineEventHandler(async (event) => {
  const body = await readBody(event);

  const bodyParsed = await createThoughtSchema.safeParseAsync(body);

  if (!bodyParsed.success) {
    throw createError({
      message: bodyParsed.error.issues[0].message,
      status: 422,
    });
  }

  const thought = await db.thought.create({
    data: {
      username: bodyParsed.data.name,
      text: bodyParsed.data.text,
    },
  });

  return thought;
});
```

Последовательность такая: мы парсим `body` из входящего `event` с помощью метода `Nuxt` `readBody`, потом с помощью `zod` схемы, которую мы объявили ранее, парсим `body` методом `safeParseAsync`. Затем мы проверяем, успешно ли провалидировалось `body`, если нет, то бросаем ошибку `422` - `UNPROCESSABLE_CONTENT`с сообщением первой ошибки. Далее, мы создаем запись мысли в базе данных и возвращаем созданную запись.

Для более простого взаимодействия со статус кодами HTTP, можно использовать библиотеку `http-status-codes`:

```ts
import { StatusCodes } from "http-status-codes";

throw createError({
  message: bodyParsed.error.issues[0].message,
  status: StatusCodes.UNPROCESSABLE_ENTITY,
});
```

Также можно написать метод для более короткой записи парсинга по схеме `zod`:

```ts
import { StatusCodes } from "http-status-codes";
import { ZodSchema } from "zod";

export const parseOrThrow = async <T extends Record<PropertyKey, unknown>>(
  data: unknown,
  schema: ZodSchema<T>,
  // используем Generic для переиспользования функции с любой схемой
): Promise<T> => {
  const parsed = await schema.safeParseAsync(data);

  if (!parsed.success) {
    throw createError({
      message: parsed.error.issues[0].message,
      statusCode: StatusCodes.UNPROCESSABLE_ENTITY,
    });
  }

  return parsed.data;
};
```

Используем ее так (не забываем убрать `.data` с `bodyParsed`):

```ts
const bodyParsed = await parseOrThrow(body, createThoughtSchema);

const thought = await db.thought.create({
  data: {
    username: bodyParsed.name,
    text: bodyParsed.text,
  },
});
```

Под конец, файл выглядит так:

```ts
import { createThoughtSchema } from "~/schemas/thought";
import { db } from "~/server/db";

export default defineEventHandler(async (event) => {
  const body = await readBody(event);

  const bodyParsed = await parseOrThrow(body, createThoughtSchema);

  const thought = await db.thought.create({
    data: {
      username: bodyParsed.name,
      text: bodyParsed.text,
    },
  });

  return thought;
});
```

## Взаимодействие клиента с сервером

Теперь давайте свяжем логику сервера с нашей формой. В `app.vue` внесем следующие изменения:

```vue
<script setup lang="ts">
import { type ThoughtFormRef } from "~/components/thought/form/types";
import type { CreateThoughtSchema } from "~/schemas/thought";

const error = ref("");
const formRef = ref<ThoughtFormRef>();

const handleSubmit = async (data: CreateThoughtSchema) => {
  try {
    await $fetch("/thought", {
      method: "POST",
      body: data,
    });
    formRef.value?.handleResetForm();
  } catch (err) {
    if (err instanceof Error) {
      error.value = err.message;
    }
  }
};
</script>

<template>
  <div class="max-w-md mx-auto mt-4">
    <ThoughtForm ref="formRef" @submit="handleSubmit" :error="error" />
  </div>
</template>
```

Мы добавили состояние `error` для хранения ошибки и метод для отправки запроса на сервер с помощью `$fetch`. После успешной отправки формы мы будем сбрасывать состояние формы. При ошибке - чекать `err` на принадлежность к инстансу `Error`, чтобы не возникло ошибки с типами и не писать `any`, и переопределяем состояние `error`.

Попробуйте добавить мысль. Если форма сбросилась - значит мысль добавлена успешно 😀

## Отображение мыслей

Для отображения списка мыслей последуем тому же сценарию разработки. Для начала создадим компоненты `ThoughtCard` и `ThoughtList` в папке `components/thought`:

`ThoughtCard.vue`

```vue
<script setup lang="ts">
import { type Thought } from "@prisma/client";

interface Props {
  thought: Thought;
}

defineProps<Props>();
</script>

<template>
  <Card>
    <CardHeader class="pb-4 pt-4">
      <CardTitle>
        <span class="text-sm text-muted-foreground"> От: &nbsp;</span>
        {{ thought.username }}
      </CardTitle>
    </CardHeader>
    <CardContent>
      <p class="text-lg text-muted-foreground truncate">
        {{ thought.text }}
      </p>
      <p class="text-xs mt-3 ml-auto w-fit text-muted-foreground">
        {{ new Date(thought.createdAt).toLocaleString() }}
      </p>
    </CardContent>
  </Card>
</template>
```

Тут мы отображаем имя пользователя, текст сообщения и отформатированную локально дату создания мысли в `Card`. В качестве типа используем генерируемый тип `Thought` из `@prisma/client`.

`ThoughtList.vue`

```vue
<script setup lang="ts">
import type { Thought } from "@prisma/client";

interface Props {
  thoughts: Thought[];
}

defineProps<Props>();
</script>

<template>
  <section>
    <h4
      v-if="thoughts.length === 0"
      class="text-center text-lg text-muted-foreground"
    >
      В базе нет мыслей...
    </h4>

    <ul v-else class="flex flex-col gap-2" role="list">
      <li v-for="thought in thoughts" :key="thought.id">
        <ThoughtCard :thought="thought" />
      </li>
    </ul>
  </section>
</template>
```

В этом компоненте мы отрисовываем `<section>` с текстом, что мыслей нет, или если они есть, то выводим `ul` список карточек.

В компоненте страницы добавим вызов хука `useFetch`:

```ts
const { data: thoughts, status } = await useFetch<Thought[]>("/thought", {
  method: "GET",
  default: () => [],
});
```

`useFetch` - один из способов получить данные с API в `Nuxt`. Он специально адаптирован для работы с внутренними серверными роутами. Для использования стороннего апи можно было бы использовать `useAsyncData`. Хотя `useFetch` сам подтягивает возвращаемое значение ручки `/thought`, мы указываем Generic: `<Thought[]>` и `default` значение вызова, чтобы не было ошибки с типами в компоненте.

В `<template>` добавляем следующее:

```vue
<p class="text-destructive text-md" v-if="status === 'error'">
      {{ error }}
    </p>
<ThoughtList :thoughts="thoughts" v-else />
```

чтобы отображать ошибку, если она есть, или список, в который мы прокидываем переменную `thoughts`.

Нам осталось только добавить серверный роут `/thought` для `GET` запроса в файле `server/routes/index.get.ts`:

```ts
import { db } from "~/server/db";

export default defineEventHandler(async (event) => {
  // сортируем по новизне
  return db.thought.findMany({
    orderBy: {
      createdAt: "desc",
    },
  });
});
```

Посмотрим на то, что получилось:

![[Pasted image 20240823143416.png]]

Для хорошего UX (User Experience), добавим обновление списка после успешного отправки формы:

```ts
const {
  data: thoughts,
  status,
  refresh,
} = await useFetch<Thought[]>("/thought", {
  method: "GET",
  default: () => [],
});

const handleSubmit = async (data: CreateThoughtSchema) => {
  try {
    await $fetch("/thought", {
      method: "POST",
      body: data,
    });

    formRef.value?.handleResetForm();

    await refresh();
  } catch (err) {
    if (err instanceof Error) {
      error.value = err.message;
    }
  }
};
```

Мы деструктуризируем метод `refresh` из `useFetch` и используем его в `handleSubmit`. Попробуйте - теперь новая мысль будет сразу же появляться на экране.

Поздравляю 😏 Вместе мы успешно написали небольшое `CRUD` приложение на `Nuxt` с нашей собственной базой данных. Мы подходим к концу - осталось купить хостинг базы и облачный сервер, а также загрузить код туда вместе с `Dockerfile`, и наш проект увидит свет!

## Деплой

Для деплоя мы сделаем следующее:

- Напишем `Dockerfile`
- Купим сервер с базой данной
- Купим облачный сервер и настроим переменные окружения
- Создадим `Github` репозиторий и запушим наш проект туда
- Задеплоим наше приложение 🤫

### Покупка базы данных

Теперь давайте перейдем к покупке базы данных. Отправимся по ссылке на хостинг:
https://timeweb.cloud/my/database/create?type=mysql&zone=spb-4&preset=341 (в меню - `Базы данных` -> `создать`). Выбирайте подходящие вам характеристики базы данных - можно оставить все стандартным, или перенести сервер в Нидерланды и взять конфигурацию помощнее.

После нажатия кнопки заказать нужно подождать пару минут для запуска базы:

![[Pasted image 20240823193027.png]]

Пока ждем, создадим нового пользователя:

![[Pasted image 20240823205240.png]]и назовем его `user`. Выдайте этому пользователю пароль без специальных символов. Далее, давайте соберем публичную строку подключения к базе:

`mysql://user:{ВАШ ПАРОЛЬ}@{ВАШ IP}:3306/default_db`

В итоге база должна перейти в состояние "Включена":

![[Pasted image 20240823193312.png]]

### Github

Теперь давайте создадим репозиторий на гитхабе и запушим туда код. Для этого заходим на `github.com` и нажимаем кнопку с плюсом справа вверху. Создаем приватный репозиторий и копируем на него ссылку в браузере. В проекте прописываем `git remote add origin {ССЫЛКА}`.

Перед тем, как создать коммит, давайте напишем `npx prisma migrate dev` с поднятой в докере базой данных. `Prisma` создаст файл с миграциями, который мы используем в `Dockerfile` для применения их к продакшен базе. Далее создаем коммит и отправляем его в репозиторий командой `git push -u origin HEAD`.

### Покупка сервера

Переходим по ссылке https://timeweb.cloud/my/apps/create (или же в меню - Apps -> Создать). В переключателе вкладок выбираем `Dockerfile`:

![[Pasted image 20240823202346.png]]

Нажимаем кнопку `Добавить аккаунт`:

![[Pasted image 20240823202640.png]]

После привязки аккаунта, выбираем наш репозиторий:

![[Pasted image 20240823202701.png]]

И тот же регион, что выбирали для базы данных. Это снизит задержку.

На этом шаге важно выбрать сервер с как минимум 4гб оперативной памяти для билда проекта. К сожалению я не нашел способа избежать ошибки нехватки памяти с более слабыми конфигурациями:

![[Pasted image 20240823202806.png]]

Под конец, добавим единственную переменную окружения - строку, что составили раннее под названием `DATABASE_URL`:

![[Pasted image 20240823202941.png]]

После этого запускаем деплой, но пока ничего не ждем. Остался последний шаг - написать `Dockerfile` и запушить его.

### Dockerfile

В `Dockerfile` мы распишем все этапы сборки проекта в контейнер, при этом учитывая то, чтобы `Timeweb` понял, что мы от него хотим. Перед созданием `Dockerfile`, давайте создадим `.dockerignore`. Этот файл внесет в черный список все файлы, которые мы не хотели бы переносить из проекта в контейнер, вроде папки гит репозитория или уже готового `.nuxt` билда:

```dockerignore
node_modules/
startup.sh

# игнорируем все скрытые файлы и папкиё, которые начинаются с точки
.*
```

Теперь создадим `Dockerfile` в корне проекта. Мы разобьем деплой на части, чтобы был понятен процесс сборки проекта.

Стадия первая: выбираем нужный образ (`node-slim`), добавляем `package.json` и `package-lock.json` и устанавливаем зависимости. Также нам нужно прокинуть `ARG` `DATABASE_URL` для приложения:

```Dockerfile
ARG NODE_VERSION=20

FROM node:${NODE_VERSION}-alpine

ARG DATABASE_URL
ENV DATABASE_URL ${DATABASE_URL}

WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install
```

Копируем остальные файлы, запускаем миграции и билдим проект:

```Dockerfile
COPY . .

RUN npx prisma migrate deploy
RUN npx prisma generate

RUN npm run build
RUN npm prune
```

Создаем финальный образ, в который скопируем готовый билд, запустим его на порту 3000 и откроем порт для того, чтобы `Timeweb` знал на каком порту нужно прослушивать приложение:

```Dockerfile
ENV PORT=3000

CMD ["node", "/app/.output/server/index.mjs"]

EXPOSE 3000
```

Финальный `Dockerfile` будет выглядеть так:

```dockerfile
ARG NODE_VERSION=20

FROM node:${NODE_VERSION}-alpine

ARG DATABASE_URL
ENV DATABASE_URL ${DATABASE_URL}

WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install

COPY . .

RUN npx prisma migrate deploy
RUN npx prisma generate

RUN npm run build
RUN npm prune

ENV PORT=3000

CMD ["node", "/app/.output/server/index.mjs"]

EXPOSE 3000

```

Теперь давайте отправим изменения в репозиторий и посмотрим за билдом! Сделать это можно, если перейти во вкладку деплой и нажать `Включить расширенные логи` (нужно будет немного подождать):

![[Pasted image 20240823203109.png]]

Когда деплой успешно завершится, перейдем по домену, который указан в дашборде нашего приложения:

![[Pasted image 20240823210657.png]]

Готово 😇

![[Pasted image 20240823210817.png]]

В проект также можно добавить `SEO` информацию и фавиконку - их можно добавить в `nuxt.config.ts` по гайду `Nuxt` здесь: https://nuxt.com/docs/getting-started/seo-meta. Еще интересно было бы обзавестись авторизацией, чтобы можно было отличать пользователей друг от друга не только на основе одного поля ввода, а также ограничить доступ к сообщениям людям без аккаунта. Для красоты можно было бы добавить красивый навбар с лого в виде какой-нибудь черепахи и кнопкой входа, а также переключателем темной темы, которую можно сгенерировать тут: https://zippystarter.com/tools/shadcn-ui-theme-generator.

Надеюсь, вы еще будете пользоваться `Nuxt` и, возможно доработаете этот проект =) Спасибо за время, потраченное на мою статью. Хорошего времени суток и удачных приложений на `Nuxt`!
