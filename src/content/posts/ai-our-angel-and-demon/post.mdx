---
slug: "hidden-perils-of-using-ai"
title: "Hidden perils of using AI"
description: "For every pleasure there is a cost. In this
article I want to explore what is the price to use AI
outside money and time to tinker with it."
date: 2025-03-01
updatedDate: 2025-03-06
draft: false
image: ./image.jpg
---

I've been thinking about making such article for a while, and I finally want to write it down. In the process, I've been at first quite critical, but in the second revision (the one you're reading now), I want to empathise both sides to AI question, without being excessively polar. AI is everywhere, it is in on the cloud, our computers, in our phones, in our dreams of AGI, soon in our microwaves. It feels like if your product doesn't use AI, it is out of the real players' league. Citing Samsung, AI, AI, AI:

import MdxIframe from '@/components/mdx/MdxIframe.astro'
import MdxImage from '@/components/mdx/MdxImage.astro'

<MdxIframe src="https://www.youtube.com/embed/UyyYbl0huC4"/>

Citing Uncle Ben, _"With great power.."_, I believe we all need to consider how profitable for us this new invention is, and what are the downsides to it. Of course, I will rationalise more here on the pitfalls of using it - loss of skills, less pleasure from coding and decreased ability to withstand difficulties - because it is quite clear what Artificial Intelligence and Large Language Models do for us and how they are _certainly_ very good.

In our times of overflowing chalice of information, it is of utmost importance to not drown.

## Eyes of the Angel

AI is a benefit for every programmer, for every human being, for humanity as a whole. This is important to remember, even when you really want to shout that it will take your job (if you really want to, [read this](https://www.oreilly.com/radar/the-end-of-programming-as-we-know-it/)). We need to consider all viewpoints. And statistical language models are shiny. They are the revolution.  It is an incredible tool for learning, it is an incredible helper in so many tasks that will get much safer in the foreseeable future. With it, it feels like you're sitting next to a teacher complacent to every learning need of yours.

You will not find new information there, as it doesn't produce it (perhaps making art in shape of other people's art is its best at that), but you can receive it in a much more refined way. It is an abstraction to not let you near StackOverflow, or God forbid, a Github repository. There's many ways why using AI at a high enough level is beneficial. It can complete simple tedious tasks in a blink of an AI. It can remind you a solution to complex issue or give a refresher on something that you want to remind yourself. It can masterfully explain JavaScript Promises to you like you're five years old.

Even outside being a programming, in real life of finances and decisions and creative ideas, or just a quick friendly chat over sad Saturday if you need someone to talk to. It is a creative outlet that helps people to "draw" and "write" without being an experienced artist, or if you are, it can help you acquire more skills with presenting a nice to-do list. It can make funny (and sometimes dangerous) things out of nowhere or based on real world. It is a very sophisticated toy for long-term playing.

import eye from './eye.png'

<MdxImage src={eye}  alt="Big blue artifical eye" />

AI increases your productivity, whether when searching for a quick answer or even autocompleting your code in-place, jumping from window to window, leaving you to only press Tab, like Cursor does. In photography, it is of immense help to deal with the small size of phone's camera, in translation it seamlessly helps you to talk to foreigners if you're lost or practice your language skills very lively.

And on the other side, it is important to remember it is not a magic trick. Everything we use at a day-to-day basis has grounds in reality that were designed and manufactured by someone. Little gnomes do not put ink on the paper while printing, nobody outside mama Physics draws you a picture in a little box called camera. And AI is not alive - it is just a statistical model, however great it resembles the human mind.

It can blatantly lie because it is told to produce an answer, and also it can be blatantly precise, instead of giving full answers, concealing other facts that you may need in the future. When you "create" with it, it is not actually you doing the job. You can feel like your text is marvelous only to find out that nobody likes it, because AI produced a deranged piece of graphomany. It is a pleasure for a cost.

Being a programmer is not just knowing every detail, every code block, but rather having a clue about what you can possibly achieve. It is, after all, only bits and bytes, and you can build so much, but I'm talking about "real" possibilities, not imaginary ones. In theory, you can build a million dollar startup with your PC if you're smart enough, you just don't know how.

Knowing what types of transactions there are, even without sacrificing hours to study why they are needed, is an immense help when you're prototyping your solution. In the creativity and brainstorming field, every dot you encountered is your aid. Even if you will get the code working in 2 months, you need to start somewhere. And that starts when you operate on your own, surviving in the labyrinth. When you get stuck, you get a little wiser, and that stacks up. That sticks with you because you've earned it.

import kingdom from './kingdom.png'

<MdxImage src={kingdom}  alt="A close-up shot of Lego kingdom" />  

You ask ChatGPT and it tells you what you need to do to paralellize database connections, so that your banking app doesn't go broke. You copy and paste (same as copy-pasting from StackOverflow or some Github Gist, really) and go on with your life towards next issue. You build, and build, and build, you become the king programmer that resolves every issue, a God that doesn't need to know the language of the machines. AI protects you from all-so-hurtful world of gazillions of information pieces and consequences of bad decisions that you must learn to avoid them in the future.

It's like watching a course, and instead of hitting a blank empty code editor snapping you back to reality, you don't get a punishment for your high of seeming "all-knowing" to yourself. You just go on, thinking you fooled the system. But there's a difference between knowing words and using a vocabulary. It is in the fact that you don't truly know anything, you can't walk on your own, you live on crutches.

Fighting the popular argument that everything we use is a crutch, our IDE is a crutch, our Google search is a crutch - yes, they are crutches. They work well in helping us walk in otherwise bottomless pit of knowledge that humanity has accumulated. Those are the tools that help our race to be thousand-times more effective at gathering information and putting it to practice in our programming languages.

But **autocompletions**, for example, is another type of crutches. It grabs you and you can forget about your legs. First few months are cool - why would you even consider using them! But then you remember the good days of training the ankles to run just a little bit faster. The pain, followed by a relief and warm shower. You remove the crutches and you see that you cannot even stand. That's how it feels.

AI don't make our life easier by removing burden of doing from us. There _is_ a difference between being offered help and overtaking the task at hand. Tools are simplifying what we do so we can do something better. AI can be that _tool_ for us too. However, it is easy to get tricked, like with sugar or amphetamines, the pleasure is gonna hit you in the stomach and the graph will fall to rock bottom. Don't even let it start, is my advice.

### A soviet fairy tale

There's an old soviet animated short film called "Vovka in Far-way kingdom", which illustrates a person getting thrown into a comfortable civilization built long before they were born. I will describe it as fast as possible, you can [watch it here with English subtitles](https://amara.org/videos/nqebYM2MKMXR/en/3417906/) or [read the English transcript here](https://english.vvord.ru/tekst-filma/Vovka-v-Tridevyatom-carstve/2), which I hope is enough because I haven't found any other English translations.

The film starts by librarian recommending Vovka the new book - "Do it yourself", to which Vovka tells the librarian that he wishes to never do anything, and wants to receive everything he wants, and it is stupid to do anything himself. She puts him into the world of fairy-tales, telling him that she can do it because she reads the book often, and there he first meets the king which orders guards to execute him for being "the loafer" (a soviet slang for parasite of society), then he enters the fairy-tale called "Golden fish", and tries to order up an omnipotent mythical fish goddess to serve him, for which he gets kicked out, and thirdly, he meets three beautiful princesses whom he asks for knowledge but cannot listen.

import goldenFish from './golden-fish.png'

<MdxImage src={goldenFish}  alt="An angry Golden fish from the fairy tale" />  

Nearing the end, princesses tell him to go to the "Far-way kingdom". They even bid him "Good riddance". In this place, there's "Two from the chest at his behest", and they could very well be seen as a prophetic symbol for AI, although this is a metaphor for any machinery and even simple tools in general. At his surprise, they do not only produce the food for him to eat, they even eat it instead of him! He kicks them away, but soon he is faced by a magical Oven telling him that he can cook some pies in it if he wants to. He orders those "Two from the chest" to do it for him, but without Vovka's precise commands, they start chopping up the dough and kneading the wood instead of doing it in the proper way, and after he witnesses this, he removes them and tries to do everything himself, ultimately failing and settling on "Its fine either way!" breaking the poor Oven.

import twoFromChest from './two-from-chest.png'

<MdxImage src={twoFromChest}  alt="Two from the chest, big pink men with big smiles" />  

In the finale, he asks those two for tools, and starts learning himself with a scene of him in shambles of trying to chop up wood, and then helping a hag from the "Golden fish" fairy tale with a new trough. She asks him for a hut, and he doesn't refuse her, but instead tells her he doesn't know it _yet_, and starts using the book recommended by librarian in the beginning.

I believe until you experience this yourself, you won't be able to rid yourself of the fantasy of ultimate power that will certainly break down when you meet reality. That is, you can delay the meeting, but you cannot cancel it. Sooner or later it will meet you. And then you either pull up your sleeves or remain ignorant.

### Some cheap science

As with probably everything with life, especially when being a software developer, emotional resilience is one of the most important aspects to build anything, to live, even. We are met by hurtful occurrences daily, and it is up to us to surrender to them or tough it up. As in _John Wick_:

> Those who cling to death, live. Those who cling to life, die.

When you rack the life for free-falling dopamine upon yourself, you are not in the wrong - it is dopamine, which is essentially something that clawed us out of being primitive organisms into building complex machinery. Dopamine is what got us through evolution, but as sugary foods full of energy, it becomes a guilty pleasure.

Instead of suffering the pain of not knowing how to do something, not understanding the details of what you're working on, instead of this pain sparkling curiousity following with spikes of energy to tackle the issue, AI may very well remove the first step of this equation - pain. Huge stacktraces. Obscure legacy code. Infinity-spanning documentation of this old PHP framework. 

A hand comes from heaven and tells you: You don't need this to be a programmer. You can have the pleasure of making it work now. Here's the code that you can have for free. You don't even need to leave your IDE - here, gray text, autocomplete me!

That's called instant gratification. Here's a graph of how it affects dopamine, the receptor regulating our pleasure and helping us persevere through tough times for it:

import instantGratification from './instant-gratification.png'

<MdxImage src={instantGratification}  alt="Graph of instant gratification and ever-raising dopamine" />  
And as another quote says:

> The higher they fly, the harder they fall

import addictionDropToBaseline from './dopamine.png'

<MdxImage src={addictionDropToBaseline}  alt="Graph of dopamine is falls bellow the past rock bottom, creating a new worst in addiction" />  

From my personal experience, it is always much pleasurable to receive slow dopamine compared to fast pleasures, however ungratifying it is at the beginning, because it does not raise such spikes and everything is evened-out - you get pain, you recover from it, you receive pleasure. The other way is a casino, where you cannot win. If you step towards the high, you have already lost this game. Here's a Japanese saying:

> If you get on the wrong train, get off at the next station â€“ the longer you stay, the more expensive the return trip will be.

Aside from me becoming a pop-psychologist, what I'm trying to say is that we cannot evoke pleasure for free, everything comes for a cost. When cigarettes went popular, they were advertised as health-risks free and a prestigious thing. Look at any pack now. And it is better to pay outright, now, by spending time and learning. If you love it, of course.

Living in the illusion of having mastery over something while you are getting the-most-statistically-well-response to make up for your real unknowing is like consuming the news and then retelling their rhetoric like you're a genius. Although it can certainly help you to know what other people were typing more times, or unlock some quirk of technology you're using that you couldn't possibly meet in different circumstances. It is profitable.

Your brain gets weaker and weaker if you don't train it, and receiving pleasure is not it. It may be easy to relax on the couch without working out today. It is easy for two weeks, two months and then you suddenly realize that the muscles around your body were stolen by time.

If you learn to overcome challenges, you can overcome any challenge. If you scrap your way through just one single battle, it is not guaranteed, because it is not a result that matters, but rather the effort you put in. Instead of becoming a successor in one game of life, you learn how to become the successor at any game of life. Like that Pizza Tiktok guy from Papa Johns.

I remember that one story of troubled student which was assigned an impossible task of building an editor in C++ over the weekend. He then asked his mentor why he would put him to such misery, to which he replied, that it was not an editor he should have learned to build, but rather that he _can build anything in some amount of time, if he puts effort to it._ If you are results-seeking, you may earn them, but that comes at a cost of not knowing how to overcome obstacles.

True mastery comes from huge periods of time, and even though you would probably be able to navigate building software much faster than people spend learning it now, that does not make you a _master_. Building a webpage with Next.js doesn't equip you with all the knowledge of the Web - it just tells you what you need to do to build a good website, with the hands and feet provided by the creator of framework.

And it, of course, may very well be enough. I'm sure no developer knows everything. Someone's better at CSS, someone's tamed their Fortran because they are one of the last programmers doing this in the world. We don't have to learn about every nit-bit of documentation unless this is required. World is really overflowing with information, and we really are in need to filter it out so we don't become dysfunctional documentation readers that can't produce a feature.

But we need to take responsibility for what we do. It is not so much as a "requirement", but more like a path to better future - to know how our operating systems work, to know why the chat spat out this piece of code and how it connects to everything else. When the push comes to shove, you will be left blind without it. It always leaves you to wonder when will that happen. The next time your library doesn't cover everything because your business case is so obscure? But you still need to do it. How will you?

### Pack of laws

Closing up, I want to pinpoint three choices that I made to remain calm as a programmer. They are not meant to work for everyone, but you may at least look at them and evaluate, perhaps they would be helpful changes.

- Turn off AI autocompletions

If you used it long enough, it will suck. You will feel like you're sleep deprived for days. It is probably about the same as quitting an addiction. Your job is no longer fun. But listen, get through. Because if you won't quit now, it won't get better. You will have to get away from this needle. And the more you wait, the more you sink into this salty sea.

Snippets and IDE's features are more than enough to write code fast. If you want faster, use some expensive keyboard with your perfect Neovim setup, learn some keybindings and setup another monitor. The key difference here is that those things are not magic pills. They are paid from your debit, you need to make an effort to use them, you need to push the button. Autocompletions are like invisible loans. Every time you press Tab, even if you don't know it, you get a little bit worse at programming _on your own_. It is not enough for a drop of poison to kill you, but it accumulates.

- Ask the chat only for building blocks or something you know well enough

Using the chat is like using Google search, but faster. It is indeed so. However, there's a hard pull to use it as your hands, as your eyes, as your brain. Refuse it. When working on a problem, try to solve it yourself. If you don't understand something, ask for small pieces of the puzzle, but not for the solution. Every software piece is built using blocks, layers of abstraction. You are _required_ to understand what you do if you want to remain free and strong.

And you are equipped with the tool to make it go the nice route, instead of creating a torture for yourself later. It can explain things like this, without providing solutions, rather simplifying your never-ending learning process. Exploit it, as much as you can. But don't let it turn you exploitable. Verify answers. Ask for thorough explanation. And, of course, use Google. It is the door to everything the chat knows, and much more.

If you don't know how to solve the issue, try to solve it yourself. Give yourself half an hour, endure the pain that starts when you stare at the text and try to make the hardware follow your orders. If you have a question, ask it. When you're sitting in a class, would you ask the teacher for solution? More so, would he give it to you, if he's a good teacher? I think programming is always sitting in a class and learning new things all the time, even for momentary solutions, which you forget about in a minute. If your case is like this, or you already know a formula you used ten times and simply forgot it, retrieve it. A tool is a tool.

- Refuse easy pleasure, trust the process

Here is a bit messy take. It is broad, and defiant, and smug. But it is what is necessary to push towards reaching the heights. If you only strive for pleasure and achieving the next goal, it would be impossible to win anything outside of breadcrumbs others have left behind. Reaching for a new high is a glamorous undertaking, but it is important to remember that there will always be a new one. You complete one task fast, another three are returned. The faster you go, the faster you _still need to go_. Take a glass of water and let it work out with hard work.

I write these lines for myself, too. In other aspects of life I was trying to just grab the next bite of _good_. The new framework, the new shiny tool for writing my stylesheets, an understandable fight for _the most performant_ programming language. But it always leads to unhappiness of not receiving the next dose.

What I'm proposing is _learn to create_. It is hard, but the reward is not something you can just grab. Read books, go deep, finally understand how your website is _actually_ being processed by user's browser, TCP, DNS, stages of parsing the HTML into DOM, CSSOM and executing scripts, why you are writing OOP and whether you even need to switch your JavaScript environment the fourth time this year.

You don't need to _just do that, because it is required_. It is required because it brings value to your professional career, but don't just try to memorize all these things thinking they will make you a senior engineer. But you won't reach the mastery without understanding them. In the end, the program will swap itself from their copilot seat with you, and you will just be there for the sake of overseeing it. It doesn't sound fun.

---

By taking it slow and being considerable and mindful, we do not get smart at any one point in time, but over days and weeks of practicing your neurons and fingers, we start to feel much safer being out there, in hundreds of work tasks or your next pet project. Just like using Linux, we can learn the transparency that is an amazing property of software development, or take the Blue Pill and remain in the happy darkness. We will not need to find a new course, because we can finally read the docs.

On the other side, we should cherish this invention because it will make learning and doing much easier. If we apply it right and let it help us to lead instead of leading us somewhere, if we rush in the battle and suffer pain and come with experience that we can stand upon, it is really a brilliant tool.

Thanks for reading!
