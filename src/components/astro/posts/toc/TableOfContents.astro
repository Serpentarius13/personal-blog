---
import type { MarkdownHeading } from "astro";
import TocItem from "./TocItem.astro";
import { cn } from "@/lib/cn";
import { type TocHeading } from "./toc.types";
import type { ComponentProps, HTMLAttributes } from "astro/types";
import { Icon } from "@/components/preact/Icon";

interface Props extends HTMLAttributes<"aside"> {
  headings: MarkdownHeading[];
  class?: string;
}

const { headings, class: className, ...props } = Astro.props;

function buildToc(headings: MarkdownHeading[]): TocHeading[] {
  const toc: TocHeading[] = [];
  const stack: TocHeading[] = [];

  headings.forEach((h) => {
    const heading = { ...h, children: [] } satisfies TocHeading;

    while (stack.length > 0 && stack[stack.length - 1].depth >= heading.depth) {
      stack.pop();
    }

    if (stack.length === 0) {
      toc.push(heading);
    } else {
      stack[stack.length - 1].children?.push(heading);
    }

    stack.push(heading);
  });

  return toc;
}

const toc = buildToc(headings.filter((h) => h.depth !== 1));
---

<aside {...props} class={cn("w-0 h-0 z-[120]", className)} id="toc">
  <div
    class="peer origin-top-left rounded-box bg-base-100 shadow-md shadow-primary backdrop-blur-xl transition-all"
    id="toc-inner"
    data-open="true"
  >
    <ul
      class="scrollbar-thin scrollbar-track-gray-50 scrollbar-thumb-primary menu menu-xs max-h-[600px] w-full flex-nowrap overflow-auto p-2"
    >
      {toc.map((heading, index) => <TocItem heading={heading} index={index} />)}
    </ul>
  </div>

  <button
    id="toc-close-btn"
    class="z-[100]"
    aria-labelledby="toc-close-btn-label"
  >
    <Icon className="line-md--close toc-close-icon toc-close-icon--close" />
    <Icon className="line-md--list toc-close-icon toc-close-icon--open" />
    <span class="sr-only">Open table of contents</span>
  </button>
</aside>

<style>
  #toc-inner[data-open="false"] {
    @apply opacity-0 scale-0 z-[120];

    & ~ #toc-close-btn {
      & .toc-close-icon--open {
        @apply opacity-100;
      }

      & .toc-close-icon--close {
        @apply opacity-0;
      }
    }
  }

  #toc-close-btn {
    @apply z-[15] border-primary focus:outline-none focus:ring-2 focus:ring-secondary transition-all hover:border-primary hover:bg-primary hover:text-primary-content bg-base-100 absolute -left-5 -top-2 p-0  btn-ghost btn btn-sm w-10 h-10 flex items-center justify-center rounded-full;

    & .toc-close-icon--open {
      @apply opacity-0;
    }

    .toc-close-icon {
      @apply text-2xl absolute;

      &.toc-close-icon--close {
      }

      &.toc-close-icon--open {
      }
    }
  }
</style>

<script>
  function main() {
    const closeButton = document.querySelector("#toc-close-btn")!;
    const toc = document.querySelector("#toc-inner")! as HTMLElement;

    closeButton.addEventListener("click", () => {
      toc.dataset.open = toc.dataset.open === "true" ? "false" : "true";
    });
  }

  main();
</script>

<script>
  function main() {
    if (!window.matchMedia("(min-width: 1024px)").matches) return;

    const links = document.querySelectorAll(
      "#toc-inner a[href^='#']",
    ) as NodeListOf<HTMLAnchorElement>;

    for (const link of links) {
      link.addEventListener("click", (event) => {
        event.preventDefault();
        const target = document.getElementById(
          link.getAttribute("href")!.slice(1),
        );

        target?.scrollIntoView({ behavior: "smooth", block: "start" });

        if (window.matchMedia("(max-width: 767px)").matches) {
          const tocInner = document.getElementById("toc-inner");
          if (!tocInner) return;
          tocInner.dataset.open = "false";
        }
      });
    }

    const header = document.querySelector("header");
    const headerHeight = header ? header.offsetHeight : 0;

    const observer = new IntersectionObserver(
      (sections) => {
        sections.forEach((section) => {
          const heading = section.target.querySelector("h2, h3, h4, h5, h6");
          if (!heading) return;

          const id = heading.getAttribute("id");
          const link = document.querySelector(`#toc li a[href="#${id}"]`);
          if (!link) return;

          link.classList[section.isIntersecting ? "add" : "remove"]("seeing");
        });
      },
      {
        rootMargin: `-${headerHeight}px 0px 0px 0px`,
      },
    );

    const sections = document.querySelectorAll(".prose section");
    sections.forEach((section) => {
      observer.observe(section);
    });
  }

  main();
</script>
